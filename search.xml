<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ETL基础知识</title>
    <url>/2021/04/04/ETL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>介绍ETL数据同步基础知识。包含ETL概念和简介，ETL抽取策略。</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ETL即数据抽取（Extract）、转换（Transform）、装载（Load）的过程。</p>
<h3 id="抽取策略"><a href="#抽取策略" class="headerlink" title="抽取策略"></a>抽取策略</h3><ul>
<li>时间戳方式</li>
</ul>
<p>需要在<em>OLTP</em>（<strong>联机事务处理系统）</strong>系统中业务表中统一添加时间字段作为时戳（如表中已有相应的时间字段，可以不必添加），每当<em>OLTP</em>系统中更新修改业务数据时，必须同时修改时戳字段值。当作<em>ETL</em>加载时，通过系统时间与时戳字段的比较来决定进行何种数据抽取。</p>
<p>​    优点：<em>ETL</em>系统设计清晰，源数据抽取相对清楚简单，速度快。<strong>可以实现数据的递增加载</strong>。</p>
<p>​    缺点：时戳维护需要由<em>OLTP</em>系统完成，需要修改原<em>OLTP</em>系统中业务表结构；且所有添加时戳的表，在业务系统中，数据发生变化时，同时更新时戳字段，需要对原<em>OLTP</em>系统业务操作程序作修改，工作量大，改动面大，风险大。但如果业务表在最初设计的时候考虑到这点，应用此方案是最好的选择。</p>
<ul>
<li>日志表方式</li>
</ul>
<p>在<em>OLTP</em>系统中添加系统日志表，当业务数据发生变化时，更新维护日志表内容，当作<em>ETL</em>加载时，通过读日志表数据决定加载那些数据及如何加载。</p>
<p>​    优点：不需要修改<em>OLTP</em>表结构，源数据抽取清楚，速度较快。<strong>可以实现数据的递增加载。</strong></p>
<p>​    缺点：日志表维护需要由<em>OLTP</em>系统完成，需要对<em>OLTP</em>系统业务操作程序作修改，记录日志信息。日志表维护较为麻烦，对原有系统有较大影响。工作量较大，改动较大，有一定风险。</p>
<ul>
<li>全表比对方式</li>
</ul>
<p>在<em>ETL</em>过程中，抽取所有源数据，并进行相应规则转换，完成后先不插入目标，而对每条数据进行目标表比对。根据主键值进行插入与更新的判定，目标表已存在该主键值的，表示该记录已有，并进行其余字段比对，如有不同，进行<em>Update</em>操作，如目标表没有存在该主键值，表示该记录还没有，即进行<em>Insert</em>操作。</p>
<p>优点：对已有系统表结构不产生影响，不需要修改业务操作程序，所有抽取规则由<em>ETL</em>完成，管理维护统一，可以实现数据的递增加载，没有风险。</p>
<p>缺点：<em>ETL</em>比对较复杂，设计较为复杂，速度较慢</p>
<ul>
<li>全表删除插入方式</li>
</ul>
<p>每次<em>ETL</em>操作均删除目标表数据，由<em>ETL</em>全新加载数据。</p>
<p>​    优点：<em>ETL</em>加载规则简单，速度快。</p>
<p>​    缺点：对于维表加代理键不适应，当<em>OLTP</em>系统产生删除数据操作时，<em>OLAP</em>层将不会记录到所删除的历史数据。不可以实现数据的递增加载。</p>
<ul>
<li>设置触发器方式</li>
</ul>
<p>通过在源系统的数据库中设置触发器，每当有<em>Update</em>、<em>Insert</em>、<em>Delete</em>操作时触发一个事件将发生改变的记录抽取到相应的临时表中。</p>
<p>​    优点：<em>ETL</em>加载规则简单，速度快，不需要修改<em>OLTP</em>表结构，可以实现数据的递增加载。</p>
<p>​    缺点：对源系统性能有一些影响。需建立一张临时表。</p>
<ul>
<li>Oracle 变化数据捕捉（CDC 方式）</li>
</ul>
<p><em>CDC</em>特性是在<em>Oracle9i</em>数据库中引入的，它简化了识别自上次提取后发生变化的数据的过程。<em>CDC</em>能够帮助识别从上次提取之后发生变化的数据。利用<em>CDC</em>，在对源表进行<em>Update</em>、<em>Insert</em>或<em>Delete</em>等操作的同时就可以提取数据，并且变化的数据被保存在数据库的变化表中。这样就可以捕获发生变化的数据，然后利用数据库视图以一种可控的方式提供给目标系统。</p>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><h4 id="oltp-olap"><a href="#OLTP-OLAP" class="headerlink" title="OLTP OLAP"></a>OLTP OLAP</h4><p>从字面上来看OLTP是做事务处理，OLAP是做分析处理。从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询。</p>
]]></content>
      <categories>
        <category>ETL</category>
      </categories>
      <tags>
        <tag>ETL基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>ETL流服务器迁移部署</title>
    <url>/2021/03/30/ETL%E6%B5%81%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<blockquote>
<p>数据同步的ETL流服务器遭到挖矿程序侵入。经慎重考虑、迁移服务器。其中包括分用户、sftp用户的创建、SFTP、crontab、kettle、jdk、vnc相关服务的安装。记录生产环境相关文件的位置。配置任务、启动任务、以及在迁移部署中的一些改动。也包含服务器迁移之后其他平台的改动如：中转机、Dataworks。</p>
</blockquote>
<span id="more"></span>

<p>老的服务器版本：CentOS Linux release 7.6.1810</p>
<p>新的服务器版本：CentOS Linux release 7.9.2009</p>
<p>新服务器位置：华东2（上海）syp-etl</p>
<h3 id="一-创建分用户"><a href="#一、创建分用户" class="headerlink" title="一、创建分用户"></a>一、创建分用户</h3><ul>
<li><p>一版情况下禁止以root用户登录系统</p>
</li>
<li><p>创建分用户sy-devops-user，开启sudo权限</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为普通用户添加sudo权限</span><br><span class="line">1.root用户下创建分用户</span><br><span class="line">eg: useradd syp-devops-user</span><br><span class="line">2.vim &#x2F;etc&#x2F;sudoers &#x2F;&#x2F;打开sudo的配置文件</span><br><span class="line">3.在“root ALL&#x3D;(ALL)ALL”这一行下面，加入一行： 用户名 ALL&#x3D;(ALL) ALL</span><br><span class="line">eg:syp-devops-user ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>

<h3 id="二-安装相关服务"><a href="#二、安装相关服务" class="headerlink" title="二、安装相关服务"></a>二、安装相关服务</h3><ul>
<li>sftp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装&#x2F;卸载vsftpd服务</span><br><span class="line">yum -y install vsftpd</span><br><span class="line">yun remove vsftpd</span><br><span class="line">2.创建sftp用户</span><br><span class="line">useradd -d &#x2F;home&#x2F;username username</span><br><span class="line">3.启动|关闭|重启|查看vsftpd服务器</span><br><span class="line">service vsftpd start|stop|restart|status</span><br><span class="line">4.设置sftp用户密码，尽量与原来密码一致</span><br><span class="line">passwd username</span><br><span class="line">5.通知Allergan配置数据库访问白名单 </span><br><span class="line">6.通知供应商上传服务器ip改变</span><br><span class="line">7.设置开机启动</span><br><span class="line">systemctl enable vsftpd.service</span><br></pre></td></tr></table></figure>

<ul>
<li>crontab</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装&#x2F;卸载crontab服务</span><br><span class="line">yum install -y crontabs</span><br><span class="line">yun remove crontabs</span><br><span class="line">2.启动|关闭|重启|查看服务状态</span><br><span class="line">service crond start|stop|restart|status</span><br><span class="line">3.配置定时任务,查看定时任务&#x2F;编辑定时任务</span><br><span class="line">crontab -l&#x2F;-e</span><br><span class="line">配置：minute hour day(month) month day(week)</span><br><span class="line">4.设置开机启动</span><br><span class="line">在&#x2F;etc&#x2F;rc.d&#x2F;rc.local 脚本中加入一行：&#x2F;sbin&#x2F;service crond start </span><br></pre></td></tr></table></figure>

<ul>
<li>kettle</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下载kettle安装包，当前使用版本8.2</span><br><span class="line">https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;pentaho&#x2F;files&#x2F;Data%20Integration&#x2F;</span><br><span class="line">2.通过sftp上传到服务器</span><br><span class="line">解压，kettle无需安装，运行spoon.sh</span><br><span class="line">3.设置桌面快捷方式、桌面创建kettle.desktop文件</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Encoding&#x3D;UTF-8</span><br><span class="line">Name&#x3D;kettle</span><br><span class="line">Exec&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;kettle-8.2.0.0_342&#x2F;spoon.sh</span><br><span class="line">Icon&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;kettle-8.2.0.0_342&#x2F;spoon.png</span><br><span class="line">Terminal&#x3D;false</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Categories&#x3D;Application;</span><br></pre></td></tr></table></figure>

<ul>
<li>jdk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下载jdk的linux版本安装包，当前版本8</span><br><span class="line">2.通过sftp上传到服务器</span><br><span class="line">3.安装位置：&#x2F;url&#x2F;java&#x2F;jdk1.8.0_271-amd64</span><br><span class="line">4.环境变量配置</span><br><span class="line">配置文件：&#x2F;etc&#x2F;profile</span><br><span class="line">内容：</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;user&#x2F;java&#x2F;jdk1.8.0_271-amd64</span><br><span class="line">exprot PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure>

<ul>
<li>vnc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装VNC 默认port:5901</span><br><span class="line">yum install -y tigervnc-server vnc</span><br><span class="line">2.启动桌面进程方式</span><br><span class="line">systemctl enable vncserver@:1.service</span><br><span class="line">systemctl start vncserver@:1.service</span><br><span class="line">3.查看运行的桌面</span><br><span class="line">vncserver -list</span><br><span class="line">4.查看某个桌面进程的状态</span><br><span class="line">systemctl status vncserver@:1.service</span><br><span class="line">5.杀掉某个桌面</span><br><span class="line">vncserver -kill :1</span><br><span class="line">6.设置Vnc密码</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure>

<ul>
<li>通过阿里云自带的vnc连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.阿里云平台-&gt;控制台-&gt;云服务器ESC-&gt;对应服务器-&gt;远程连接-&gt;选择VNC远程连接</span><br></pre></td></tr></table></figure>

<ul>
<li>CentOS 中文化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前语言</span><br><span class="line">echo $LANG</span><br><span class="line">2.查看当前支持的所有语言，如果有“zh_cn”则有中文</span><br><span class="line">locale</span><br><span class="line">3.安装中文语言包</span><br><span class="line"> centos7：yum install kde-l10n-Chinese   centos6:yum groupinstall Chinese-support</span><br><span class="line">4.查看是否安装成功</span><br><span class="line">locale -a | grep &quot;zh_CN&quot;</span><br><span class="line">5.备份修改配置文件</span><br><span class="line">cp &#x2F;etc&#x2F;locale.conf &#x2F;home&#x2F;locale.conf.backup</span><br><span class="line">vim &#x2F;etc&#x2F;locale.conf</span><br><span class="line">将LANG&#x3D;en_US.UTF-8改成 LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">保存退出</span><br><span class="line">6.重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h3 id="三-迁移相关文件"><a href="#三、迁移相关文件" class="headerlink" title="三、迁移相关文件"></a>三、迁移相关文件</h3><ul>
<li>新建文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脚本存储位置：mkdir &#x2F;data&#x2F;work&#x2F;scripts</span><br><span class="line">数据文件存储位置:mkdir &#x2F;data&#x2F;allergan</span><br><span class="line">日志存储位置：mkdir &#x2F;data&#x2F;work&#x2F;logs</span><br><span class="line">根据业务创建不同文件夹存储不同的数据</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_ali_online</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_finance</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_sales_ab</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_sales_calls-csv</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_sales_ab-csv</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_dingtalk</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_members</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;from_transit_computer</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_members&#x2F;etocrmdata</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_members&#x2F;etocrm_data</span><br><span class="line">mkdir &#x2F;data&#x2F;allergan&#x2F;allergan_members&#x2F;executed_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建SFTP用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中转机：allergan_sales_ab 主目录：&#x2F;data&#x2F;allergan&#x2F;allergan_sales_ab</span><br><span class="line">小艾数据：allergan_members 主目录：&#x2F;data&#x2F;allergan&#x2F;alergan_members</span><br><span class="line">eg:</span><br><span class="line">useradd  &#x2F;data&#x2F;allergan&#x2F;allergan_sales_ab -g whell allergan_sales_ab</span><br><span class="line">useradd  &#x2F;data&#x2F;allergan&#x2F;allergan_members -g allergan_members allergan_members</span><br><span class="line">注意修改主目录的权限给各个用户</span><br><span class="line">eg:</span><br><span class="line">chown -R allergan_members.allergan_members &#x2F;data&#x2F;allergan&#x2F;alllergan_members</span><br><span class="line">chown -R allergan_sales_ab.whell &#x2F;data&#x2F;allergan&#x2F;allergan_sales_ab</span><br><span class="line">修改配置文件vsftpd.conf,将sftp用户限制在主目录中</span><br><span class="line">eg:</span><br><span class="line">vim &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</span><br><span class="line">修改chroot_local_user&#x3D;YES # 将SFTP本地用户禁锢在宿主目录中</span><br></pre></td></tr></table></figure>

<ul>
<li>迁移文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">使用xftp等工具，将老的Etl服务器的脚本拿出，再通过xftp等工具放入到新的服务器中</span><br><span class="line">方法二：</span><br><span class="line">进入老的ETL服务器终端直接使用命令</span><br><span class="line">eg:</span><br><span class="line">scp &#x2F;data&#x2F;allergan -r  root@etl.idata.mobi:&#x2F;data&#x2F;</span><br><span class="line">scp &#x2F;data&#x2F;work&#x2F;scripts -r  root@etl.idata.mobi:&#x2F;data&#x2F;work&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="四-配置启动相关任务"><a href="#四、配置启动相关任务" class="headerlink" title="四、配置启动相关任务"></a>四、配置启动相关任务</h3><ul>
<li>crontab 定时任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.crontab定时任务配置</span><br><span class="line">eg:crontab -e </span><br><span class="line">写入</span><br><span class="line">00 07 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;members_fans&#x2F;tools.sh</span><br><span class="line">30 07 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;members_fans_azure&#x2F;tools.sh</span><br><span class="line">25 06 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;user_questionnaires&#x2F;tools.sh</span><br><span class="line">30 06 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;user_questionnaires_azure&#x2F;tools.sh</span><br><span class="line">20 19 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;user_behaviors&#x2F;tools.sh</span><br><span class="line">30 19 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;user_behaviors_azure&#x2F;tools.sh</span><br><span class="line">00 00 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;sales_ab&#x2F;tools.sh</span><br><span class="line">00 00 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;sales_ab_azure&#x2F;tools.sh</span><br><span class="line"># 00 06 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;amap&#x2F;tools.sh</span><br><span class="line"># 00 06 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;amap_azure&#x2F;tools.sh</span><br><span class="line">30 22 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;digital_ami&#x2F;tools.sh</span><br><span class="line">30 22 * * 0 &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;digital_ami_azure&#x2F;tools.sh</span><br><span class="line">00 01 * * * &#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;transit_computer_azure&#x2F;tools.sh</span><br><span class="line">2.注意修改文件为可执行文件</span><br><span class="line">eg:chmod +x &#x2F;data&#x2F;work&#x2F;scritps&#x2F;allergan&#x2F;digital_ami_azure&#x2F;tools.sh</span><br><span class="line">2.重启crontab</span><br><span class="line">service crond restart</span><br></pre></td></tr></table></figure>

<h3 id="五-其他修改新增"><a href="#五、其他-修改-新增" class="headerlink" title="五、其他(修改+新增)"></a>五、其他(修改+新增)</h3><ul>
<li>中转机ETL流任务修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有两个ETL流任务中需要添加一个sftp上传,将销售相关数据上传一份到新的ETL流服务器</span><br><span class="line">脚本位置：</span><br><span class="line">D:&#x2F;customer-client&#x2F;allergan_data_etl.kjb</span><br><span class="line">D:&#x2F;customer-client&#x2F;allergan_data_etl_hospital.kjb</span><br></pre></td></tr></table></figure>

<ul>
<li>Dataworks任务流修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据集成，添加数据源FTP</span><br><span class="line">2.修改节点：amap_hospital_name_ftp_to_odps的数据源</span><br><span class="line">注：这个节点是直接从etl流服务器拿数据</span><br></pre></td></tr></table></figure>

<ul>
<li>脚本任务有改动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.用户问卷</span><br><span class="line">更新频率：日</span><br><span class="line">齐数上传时间：6:00</span><br><span class="line">任务执行时间：7:00（azure）7:10（ali）</span><br><span class="line">文件名称：user_questionnaire_detail_时间戳.zip</span><br><span class="line">执行顺序：先入库azure,再入库ali</span><br><span class="line">流程：拷贝文件到executed_file中一份，再重命名文件为questionnaire_details.zip，再执行kjb（azure）脚本将文件解压到etocrm_data中并删除questionnaire_details.zip文件。读取解压后的美丽问卷.csv到数据库中。ali脚本直接运行kjb，读取美丽问卷.csv,不再需要解压缩。</span><br></pre></td></tr></table></figure>

<ul>
<li>Menarini脚本需要改动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.menarini的数据上传地址需要改动etl.idata.mobi</span><br><span class="line">Teamviewer连接menarini远程公共机</span><br><span class="line">kettle位置：C:\WorkSpace\pdi-ce-9.0.0.0-423\data-integration</span><br><span class="line">脚本位置：C:\WorkSpace\Menarini\kettle\sftp_table.kjb</span><br></pre></td></tr></table></figure>

<ul>
<li>增加任务流程 中转机需要每天更新的表DDI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.中转机</span><br><span class="line">中转机脚本位置：D:\customer-client\allergan_data_every_day.kjb</span><br><span class="line">kettle程序位置：E:\Download\kettle\data-integration</span><br><span class="line">自动化脚本位置：C:\Users\SYWin02\Desktop\every_day_job.bat</span><br><span class="line">定时设置步骤：计算机管理-&gt;任务计划程序-&gt;创建基本任务</span><br><span class="line">定时任务名称：每天同步到etl.idata.mobi服务器的数据定时任务</span><br><span class="line">运行日志脚本位置：D:\log\every_day时间戳.log</span><br><span class="line">2.ETL服务器</span><br><span class="line">脚本位置：&#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;transit_computer_azure</span><br><span class="line">日志位置：&#x2F;data&#x2F;work&#x2F;log&#x2F;transit_computer_azure_时间戳.log</span><br><span class="line">接受数据文件位置：&#x2F;data&#x2F;allergan&#x2F;from_transit_computer</span><br></pre></td></tr></table></figure>

<ul>
<li>增加任务流程 验真扫码数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ETL服务器</span><br><span class="line">脚本位置：&#x2F;data&#x2F;work&#x2F;scripts&#x2F;allergan&#x2F;scancode_azure</span><br><span class="line">日志位置：&#x2F;data&#x2F;work&#x2F;logs&#x2F;scan_时间戳.log</span><br><span class="line">接受数据文件位置：&#x2F;data&#x2F;allergan&#x2F;allergan_members&#x2F;scancode_时间戳.zip</span><br></pre></td></tr></table></figure>

<ul>
<li>表情包编码异常数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ETL例子：ami_business_school.job we_chat_user.ktr</span><br><span class="line">2.表输入数据库连接编码：characterEncoding utf8  </span><br><span class="line">3.表&amp;字段编码：utf8mb4</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过kettle上传数据到maxcompute</p>
<p>下载kettle的maxcompute插件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aliyun-kettle-odps-plugin-2.0.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>官方文档地址：<a href="https://developer.aliyun.com/article/68911">https://developer.aliyun.com/article/68911</a>  ［ETL实践指南］基于Kettle的MaxCompute插件实现数据上云</p>
<p>AccessID和Accesskey获取：阿里云账号头像-&gt;Accesskey管理-&gt;创建AccessKey-&gt;得到AccessKey ID (AccessID)和 AccessKey Secret(AccessKey)  </p>
<h3 id="六-疑问"><a href="#六、疑问" class="headerlink" title="六、疑问"></a>六、疑问</h3><ul>
<li>中转机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在allergan_data_etl.job中有取自Pchina_calls_tables.txt的表的同步任务，不知道做什么用</span><br><span class="line">2.除了D:\customer-client\allergan_data_every_day.kjb任务的脚本定时任务，其他任务的定时任务脚本不知道在哪里设置的·</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel基础知识</title>
    <url>/2021/04/09/Excel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍数据库SQL基础语法及相应函数。包含表的增删改查。</p>
</blockquote>
<span id="more"></span>

<h2 id="excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h2><h4 id="excel拆分sheets"><a href="#Excel拆分Sheets" class="headerlink" title="Excel拆分Sheets"></a>Excel拆分Sheets</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Private Sub 分拆工作表()    </span><br><span class="line">Dim sht As Worksheet      </span><br><span class="line">Dim MyBook As Workbook     </span><br><span class="line">Set MyBook &#x3D; ActiveWorkbook      </span><br><span class="line">For Each sht In MyBook.Sheets        </span><br><span class="line">sht.Copy</span><br><span class="line">ActiveWorkbook.SaveAs Filename:&#x3D;MyBook.Path &amp; &quot;\&quot; &amp; sht.Name, FileFormat:&#x3D;xlOpenXMLWorkbook     &#39;将工作簿另存为xlsx格式           ActiveWorkbook.Close     </span><br><span class="line">Next      </span><br><span class="line">MsgBox &quot;文件已经被分拆完毕!&quot;  </span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<h4 id="分离中英文"><a href="#分离中英文" class="headerlink" title="分离中英文"></a>分离中英文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;LEFT(A1,LENB(A1)-LEN(A1))</span><br></pre></td></tr></table></figure>

<h4 id="英文月份变为数字"><a href="#英文月份变为数字" class="headerlink" title="英文月份变为数字"></a>英文月份变为数字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;MONTH(A20&amp;&quot;-1&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="一维表变二维表"><a href="#一维表变二维表" class="headerlink" title="一维表变二维表"></a>一维表变二维表</h4><p>数据-自表格/区域-逆转置</p>
<h4 id="数字变ym"><a href="#数字变YM" class="headerlink" title="数字变YM"></a>数字变YM</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;if(A1&lt;10,2020&amp;&quot;0&quot;&amp;A1,2020&amp;A1)</span><br></pre></td></tr></table></figure>

<h4 id="英文月份变ym"><a href="#英文月份变YM" class="headerlink" title="英文月份变YM"></a>英文月份变YM</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;IF(MONTH(J3&amp;&quot;-1&quot;)&lt;10,2019&amp;&quot;0&quot;&amp;MONTH(J3&amp;&quot;-1&quot;),2019&amp;MONTH(J3&amp;&quot;-1&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="同步两个sheet数据"><a href="#同步两个sheet数据" class="headerlink" title="同步两个sheet数据"></a>同步两个sheet数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Private Sub Worksheet_Change(ByVal Target As Range)</span><br><span class="line">Application.EnableEvents &#x3D; False</span><br><span class="line">Sheet1.Range(&quot;a1:z999&quot;).Copy Sheet2.Range(&quot;a1&quot;)</span><br><span class="line">Application.EnableEvents &#x3D; True</span><br><span class="line">Sheet1.Range(&quot;a1&quot;).Select</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<h4 id="vlookup"><a href="#vlookup" class="headerlink" title="vlookup"></a>vlookup</h4><p>注意查找的数据与查找数据域的第一列匹配</p>
]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础命令</title>
    <url>/2021/04/09/Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍数据库SQL基础语法及相应函数。包含表的增删改查。</p>
</blockquote>
<span id="more"></span>

<h4 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h4><ul>
<li>查看远程仓库地址 - git remote -v</li>
<li>拉取远程代码更新本地 git pull -p</li>
<li>拉取远程代码更新本地 git fetch –prune origin</li>
</ul>
<h4 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h4><ul>
<li>git创建分支 - git branch dev</li>
<li> 切换到该分支 - git checkout bugFix</li>
<li>git创建远程分支：- git pull origin dev:dev</li>
</ul>
<h4 id="git合并分支"><a href="#git合并分支" class="headerlink" title="git合并分支"></a>git合并分支</h4><ul>
<li><p>进入要合并的分支（如开发分支合并到master，则进入master目录）</p>
<ul>
<li><p>git checkout master</p>
</li>
<li><p>git pull</p>
</li>
</ul>
</li>
<li><p>查看本地和远程仓库的所有分支 - git branch -a</p>
</li>
<li><p>查看本地仓库所有分支 - git branch</p>
</li>
<li><p>使用merge合并开发分支 - git merge 分支名</p>
</li>
<li><p>查看合并之后的状态 - git status</p>
</li>
<li><p>将本地分支与远程保持同步 - git fecth</p>
</li>
<li><p>拉取远程分支并同时创建对应的本地分支- git checkout -b 本地分支名 origin/远程分支名</p>
</li>
<li><p>将本地所有分支与远程保持同步 git fetch –all</p>
</li>
<li><p>拉取所有分支代码 git pull –all</p>
</li>
</ul>
<h4 id="git查看与远程代码区别"><a href="#git查看与远程代码区别" class="headerlink" title="git查看与远程代码区别"></a>git查看与远程代码区别</h4><ul>
<li>git status  </li>
<li>git diff</li>
</ul>
<h4 id="windows下git-diff-正文中文乱码问题"><a href="#windows下git-diff-正文中文乱码问题" class="headerlink" title="windows下git -diff 正文中文乱码问题"></a>windows下git -diff 正文中文乱码问题</h4><ul>
<li>set LESSCHARSET=utf-8</li>
</ul>
<h4 id="代码合并提交标准"><a href="#代码合并提交标准" class="headerlink" title="代码合并提交标准"></a>代码合并提交标准</h4><ul>
<li>eg：git commit -m “<a href="mailto:&#x66;&#x69;&#120;&#x40;&#x30;&#46;&#49;&#46;&#49;">&#x66;&#x69;&#120;&#x40;&#x30;&#46;&#49;&#46;&#49;</a>/21(city): 修正店铺信息与城市的硬关联”</li>
</ul>
<h4 id="上次远程仓库"><a href="#上次远程仓库" class="headerlink" title="上次远程仓库"></a>上次远程仓库</h4><ul>
<li>git add .</li>
<li>git comment -m “”</li>
<li>git push</li>
</ul>
<h4 id="git-log-win10中文乱码"><a href="#git-log-win10中文乱码" class="headerlink" title="git log win10中文乱码"></a>git log win10中文乱码</h4><ul>
<li>bash 环境下  export LESSCHARSET = utf-8</li>
<li>cmd环境下  set LESSCHARSET = utf-8</li>
</ul>
<p>git push –set-upstream origin dev-0.1-qwb -f 强制覆盖分支</p>
<p>git branch -D dev-0.1-qwb 删除分支</p>
<p>git pull origin master</p>
<h3 id="一-建立本地仓库上传文件-按-github-新建成功的描述步骤输入命令"><a href="#一、建立本地仓库，上传文件。按-github-新建成功的描述步骤输入命令" class="headerlink" title="一、建立本地仓库，上传文件。按 github 新建成功的描述步骤输入命令"></a>一、建立本地仓库，上传文件。按 github 新建成功的描述步骤输入命令</h3><ol>
<li><p>“ git init ”</p>
</li>
<li><p>“ git add . ”（此处有 . 需要一同输入）</p>
</li>
<li><p>“git commit -m “my commit””（”my commit”为本次提交描述）</p>
</li>
<li><p>“git remote add origin <a href="https://github.com/vincentChen02/testUpload.git%E2%80%9D%EF%BC%88https%E5%9C%B0%E5%9D%80%E4%B8%BA%E5%9C%A8github%E4%B8%8A%E6%96%B0%E5%BB%BA%E4%BB%93%E7%94%9F%E6%88%90%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%89">https://github.com/vincentChen02/testUpload.git”（https地址为在github上新建仓生成的路径）</a></p>
</li>
<li><p>“git push -u origin master” （此处会弹出输入github 账号密码）</p>
</li>
</ol>
<h3 id="二-修改github仓库名"><a href="#二、修改Github仓库名" class="headerlink" title="二、修改Github仓库名"></a>二、修改Github仓库名</h3><ol>
<li>在github上重命名仓库</li>
</ol>
<p>​    setting-&gt;tag-&gt;rename</p>
<ol start="2">
<li>修改本地仓库信息</li>
</ol>
<p>​    git remote -v (检查当前远程仓库信息)</p>
<p>​    git remote set-url origin <a href="mailto:git@github.com">git@github.com</a>:username/newrepo.git (修改本地对应的远程仓库的地址)</p>
<p>​    git remote -v (确认当前远程仓库信息已修改)</p>
<h3 id="三-删除远程仓库文件"><a href="#三、删除远程仓库文件" class="headerlink" title="三、删除远程仓库文件"></a>三、删除远程仓库文件</h3><ol>
<li>将远程代码pull到本地，保持本地仓库跟远端仓库同步</li>
</ol>
<p>​    git pull （拉取最新的仓库）</p>
<ol start="2">
<li>删掉要删除的文件</li>
</ol>
<p>​    git rm filename (删除本地文件-filename:文件名)</p>
<ol start="3">
<li>提交操作</li>
</ol>
<p>​    “git commit -m “my commit””（”my commit”为本次提交描述）</p>
<ol start="4">
<li>push到远程</li>
</ol>
<p>​    “git push origin master” （此处会弹出输入github 账号密码）</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo切换主题</title>
    <url>/2021/04/03/Hexo%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍如何修改Hexo主题，包含一些详细配置如：配置标签、配置分类、配置站内搜索功能、设置代码高亮、设置头像、设置Next主题、设置文章内容加载图片、上传pdf并展示。其中也有一些错误记录。整体按照顺序描述配置过程。</p>
</blockquote>
<span id="more"></span>

<h4 id="hexogithub搭建个人博客"><a href="#hexo-github搭建个人博客" class="headerlink" title="hexo+github搭建个人博客"></a>hexo+github搭建个人博客</h4><p>百度 hexo+github有很多教程，安装教程就不写了</p>
<p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
<h4 id="获取开源的-hexo-主题"><a href="#获取开源的-Hexo-主题" class="headerlink" title="获取开源的 Hexo 主题"></a>获取开源的 Hexo 主题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h4 id="修改主题-_configyml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题 _config.yml"></a>修改主题 _config.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<ul>
<li>页面报错一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--hexo使用theme出现“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro&#x2F;post.swig‘ as post_template %&#125;“问题</span><br><span class="line">-- 原因是hexo在5.0之后把swig给删除了需要自己手动安装</span><br><span class="line">-- 解决办法：</span><br><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>

<ul>
<li>页面报错二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot GET &#x2F;%20%20</span><br><span class="line">原因:主题配置文件 || 之后加多了空格</span><br></pre></td></tr></table></figure>

<h4 id="配置标签和分类"><a href="#配置标签和分类" class="headerlink" title="配置标签和分类"></a>配置标签和分类</h4><ul>
<li>在git bash 中输入以下代码创建相应的page：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在第一步完成后会在source文件夹中出现tags和categories的文件夹，在各自的文件夹里打开index.md文件进行修改(多加上一个type属性、注意其他主题可能是layout属性)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2020-03-15 14:19:53</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置搜索功能"><a href="#配置搜索功能" class="headerlink" title="配置搜索功能"></a>配置搜索功能</h4><ul>
<li>next自带一个搜索功能，可以实现对站内内容的搜索。<br>首先需要通过如下命令安装对应的搜索插件：<br>然后在全局的配置文件（hexoblog目录下的_config.yml）中，增加配置如下内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search Config</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 100</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在git hash 中加载相应的插件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ul>
<li>打开主题内的配置文件，找到 local_search 属性，配置开启本地搜索功能。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>

<h4 id="设置代码高亮"><a href="#设置代码高亮" class="headerlink" title="设置代码高亮"></a>设置代码高亮</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available value: normal | night | night eighties | night blue | night bright</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">highlight_theme: night</span><br></pre></td></tr></table></figure>

<h4 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h4><p>j进入<code>\languages</code>文件夹，有zh-Hans.yml 文件 修改名称为zh-CN.yml ,然后设置主题语言选项为zh-CN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>

<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar: &#x2F;images&#x2F;avatar.gif</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改头像为圆形、旋转动画</p>
</li>
<li><p>修改<code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>,新增以下代码:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  &#x2F;&#x2F;设置圆形</span><br><span class="line">+  border-radius: 50%;</span><br><span class="line">+  transition: 2s all;</span><br><span class="line">&#125;</span><br><span class="line">   &#x2F;&#x2F;旋转</span><br><span class="line">+ .site-author-image:hover&#123;</span><br><span class="line">+   transform: rotate(360deg);</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>

<h4 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><ul>
<li>修改主配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<ul>
<li>安装插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<ul>
<li>图片引用设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在source下创建&#x2F;images文件夹，先把图片xx.jpg&#x2F;png复制到这个文件夹</span><br><span class="line">最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片：</span><br><span class="line">![想输入的提示名字，可不输入](&#x2F;images&#x2F;xx.jpg)</span><br></pre></td></tr></table></figure>

<ul>
<li>遇到错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行之后遇到以下错误</span><br><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;blog\source_posts\article-name\image-20210309010643180.png</span><br><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;image-20210309010643180.png</span><br><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;blog\source_posts\article-name\image-20210309010643180.png</span><br><span class="line">update link as:--&gt;&#x2F;.com&#x2F;&#x2F;image-20210309010643180.png</span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在hexo的目录下执行</span><br><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h4 id="上传pdf"><a href="#上传pdf" class="headerlink" title="上传pdf"></a>上传pdf</h4><ul>
<li>安装插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure>

<ul>
<li>配置页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 基于上传图片，与上传图片类似，只是将链接引用换成pdf</span><br><span class="line">-- 在source下创建&#x2F;pfd文件夹，先把pdf复制到这个文件夹</span><br><span class="line">-- 最后在xxxx.md中想引入pdf时，只需要在xxxx.md中按照相应格式引入pdf：</span><br><span class="line">外部链接：</span><br><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br><span class="line">本地连接：</span><br><span class="line">&#123;% pdf .&#x2F;pdf名字.pdf %&#125;</span><br><span class="line">-- 图片使用中文名称引用时会造成中文会乱码，无法正常显示，暂时没有解决</span><br></pre></td></tr></table></figure>

<h4 id="修改标签云颜色"><a href="#修改标签云颜色" class="headerlink" title="修改标签云颜色"></a>修改标签云颜色</h4><ul>
<li>修改<code>themes/next/layout/page.swig</code>文件，加入自定义样式:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &#39;#ccc&#39;, end_color: &#39;#111&#39;&#125;) &#125;&#125;</span><br><span class="line">+ &#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &#39;#9733EE&#39;, end_color: &#39;#FF512F&#39;&#125;) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改首页文章间隔宽度"><a href="#修改首页文章间隔宽度" class="headerlink" title="修改首页文章间隔宽度"></a>修改首页文章间隔宽度</h4><ul>
<li>打开<code>\themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> ，修改.post{}</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123; <span class="attribute">margin-top</span>: <span class="number">12px</span>; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改文章页宽"><a href="#修改文章页宽" class="headerlink" title="修改文章页宽"></a>修改文章页宽</h4><ul>
<li>打开<code>themes/next/source/css/_variables/base.styl</code>，找到以下字段并修改为合适的宽度：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- $content-desktop-large          &#x3D; 900px</span><br><span class="line">+ $content-desktop-large          &#x3D; 1000px</span><br></pre></td></tr></table></figure>

<h4 id="修改首页文章页宽"><a href="#修改首页文章页宽" class="headerlink" title="修改首页文章页宽"></a>修改首页文章页宽</h4><ul>
<li>打开<code>themes/next/source/css/_variables/base.styl</code>，找到以下字段并修改为合适的宽度：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- $content-desktop          	  &#x3D; 700px</span><br><span class="line">+ $content-desktop                &#x3D; 900px</span><br></pre></td></tr></table></figure>

<h4 id="翻页按钮错误显示"><a href="#翻页按钮错误显示" class="headerlink" title="翻页按钮错误显示"></a>翻页按钮错误显示</h4><p>打开<code>next &gt; layout &gt; _partials &gt; pagination.swig</code> ，将错误的html代码改为‘下一页’和‘上一页’即可！</p>
<h4 id="sidebar中post点击出错"><a href="#sidebar中post点击出错" class="headerlink" title="sidebar中post点击出错"></a>sidebar中post点击出错</h4><p>我是直接将链接去除了。打开<code>next &gt; layout &gt; _macro &gt; sidebar.swig</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;</span><br><span class="line">- &lt;a href&#x3D;&quot;&#123;&#123; url_for(config.archive_dir) &#125;&#125;&quot;&gt;</span><br><span class="line">+ &lt;a href&#x3D;&quot;&quot;&gt;</span><br><span class="line">+ &lt;a href&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="主页footer内容不居中"><a href="#主页footer内容不居中" class="headerlink" title="主页footer内容不居中"></a>主页footer内容不居中</h4><p>打开<code>next\source\css\_schemes\Mist\index.styl</code>，.footer-inner中的text-align改为center</p>
<h4 id="添加背景音乐"><a href="#添加背景音乐" class="headerlink" title="添加背景音乐"></a>添加背景音乐</h4><p>注册网易云音乐，分享歌单，获取外链播放器</p>
<p>修改 <code>themes/next/layout/_macro/sidebar.swig</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 111行左右 &#123;% endif %&#125;后</span><br><span class="line">&lt;!-- 音乐播放器 --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;110 src&#x3D;&quot;&#123;&#123; theme.background_music&#125;&#125;&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>themes/next/_config.yml</code> 配置文件中添加歌单地址配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background_music: &#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;2120628564&amp;auto&#x3D;1&amp;height&#x3D;66</span><br></pre></td></tr></table></figure>

<p>上面过程能够实现背景音乐的添加，但是一刷新页面就会导致音乐重放回到初始状态。使用 <code>Pajx</code> 实现背景音乐全局播放</p>
<h4 id="添加评论和留言板"><a href="#添加评论和留言板" class="headerlink" title="添加评论和留言板"></a>添加评论和留言板</h4><p>本来是想使用多说的评论系统，但是貌似停止服务了。而disqus需要翻墙。所以目前使用的评论系统是来必力，韩国的。</p>
<ul>
<li><p>注册账号：来必力官网<a href="https://livere.com/">https://livere.com</a></p>
</li>
<li><p>安装免费的city版本</p>
</li>
<li><p>复制data-uuid</p>
</li>
<li><p>打开主题目录下的 <code>blog/themes/next/_config.yml</code> 配置文件，定位到 <code>livere_uid</code> 字段，粘贴上刚刚复制的UID。</p>
</li>
</ul>
<p>留言板的设置与标签、分类、搜索配置类似</p>
<ul>
<li><p>进入到博客的根目录，运行命令：hexo new page guestbook</p>
</li>
<li><p>生成<code>index.md</code>，在里面可以写一些留言板介绍内容等-</p>
</li>
<li><p>修改菜单目录在themes/next/_config.yml中修改配置</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;||home</span><br><span class="line">  tags: &#x2F;tags||tags</span><br><span class="line">  categories: &#x2F;categories&#x2F;||th</span><br><span class="line">  archives: &#x2F;archives&#x2F;||archive</span><br><span class="line">  about: &#x2F;about||user</span><br><span class="line">+ guestbook: &#x2F;guestbook&#x2F;||comment #留言</span><br></pre></td></tr></table></figure>

<ul>
<li>配置语言。找到 <code>languages</code> 文件夹里面的 <code>zh-Hans.yml</code> 文件，<code>menu</code> 子项中添加留言：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">+ guestbook: 留言</span><br></pre></td></tr></table></figure>

<h4 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h4><p>需要安装“ hexo-blog-encrypt”扩展实现加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>

<p>修改文章信息头</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2020-03-13 21:12:21</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure>

<h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>这里的草稿相当于很多博客都有的“私密文章”功能。</p>
<p>会在source/drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到drafts目录之中。</p>
<p>我没有类似需求，所以没有做，具体实现请参考链接：<a href="https://www.jianshu.com/p/8e1cf1ca131b">https://www.jianshu.com/p/8e1cf1ca131b</a>  </p>
<h4 id="关于资源文件夹"><a href="#关于资源文件夹" class="headerlink" title="关于资源文件夹"></a>关于资源文件夹</h4><p>_posts下md文件过多杂乱，可以在__posts文件夹下，按照类型自己创建文件夹，但是引用图片或pdf时要注意路径。</p>
<h4 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-video</span><br></pre></td></tr></table></figure>

<p>可以将腾讯、优酷、bilibili等网站的视频嵌入到文章中</p>
<p>如 哔哩哔哩 视频有分享按钮，会生成嵌入代码。直接将嵌入代码粘贴到md就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;710997965&amp;bvid&#x3D;BV1iD4y1D714&amp;cid&#x3D;201014583&amp;page&#x3D;1&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;315&quot; &gt; &lt;&#x2F;iframe&gt; </span><br></pre></td></tr></table></figure>

<h4 id="文章列表目录跳转"><a href="#文章列表目录跳转" class="headerlink" title="文章列表目录跳转"></a>文章列表目录跳转</h4><p>正常的next主题的文章目录跳转是可以的。但是我的不行。next版本5.1.4</p>
<ul>
<li>1.渲染错误</li>
</ul>
<p>典型特征就是目录上的超链接为undefined,或者点击的时候报错 ：cannot read property ‘replace’ of null</p>
<ul>
<li>1.解决办法</li>
</ul>
<p>进入你项目根目录的 <code>node_modules\hexo-toc\lib\filter.js</code> 中，把 28 行～31 行修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$title.attr(&#39;id&#39;, id);</span><br><span class="line">&#x2F;&#x2F; $title.children(&#39;a&#39;).remove();</span><br><span class="line">&#x2F;&#x2F; $title.html( &#39;&lt;span id&#x3D;&quot;&#39; + id + &#39;&quot;&gt;&#39; + $title.html() + &#39;&lt;&#x2F;span&gt;&#39; );</span><br><span class="line">&#x2F;&#x2F; $title.removeAttr(&#39;id&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>2.超链接乱码</li>
</ul>
<p>渲染没有问题，但是点击目录链接会在控制台报错：cannot read property ‘top’ of undefined。打开我们打开控制台，查看目录的的超链接标签，会看到 href 是一串乱码。我们去找他对应的标题，实际上直接点击这个超链接是可以跳转的，但是点目录却不行。这是因为标题 id 是中文，但是目录的连接是中文乱码，代码里头的 JQuery 选择器拿着乱码是没法找到对应 id 的标题的。</p>
<ul>
<li>2.解决办法</li>
</ul>
<p>这个错误很明显，因为控制台已经告诉我错误代码在 <code>post-details.js</code>里了，顺着提示找到 <code>themes\next\source\js\src\post-details.js</code>，找到第 73 行为目录绑定点击事件的方法，会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $(&#39;.post-toc a&#39;).on(&#39;click&#39;, function (e) &#123;</span><br><span class="line">   e.preventDefault();</span><br><span class="line">   var targetSelector &#x3D; NexT.utils.escapeSelector(this.getAttribute(&#39;href&#39;));</span><br><span class="line">&#x2F;&#x2F;对获取到的URL进行重编码</span><br><span class="line">targetSelector &#x3D; decodeURI(this.getAttribute(&#39;href&#39;))</span><br><span class="line">   var offset &#x3D; $(targetSelector).offset().top;</span><br></pre></td></tr></table></figure>

<p><code>targetSelector</code>就是对应标题的 id，我们在他被塞到选择器之前重新编码一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对获取到的url进行重编码</span><br><span class="line">targetSelector &#x3D; decodeURI(this.getAttribute(&#39;href&#39;))</span><br></pre></td></tr></table></figure>

<p>我首先遇到第一个问题，按照解决办法解决后，又遇到第二个问题。目前记录的两种办法正对我的问题。</p>
<p>参考：<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">https://www.cnblogs.com/Createsequence/p/14150758.html</a></p>
<p>​            <a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2</a></p>
<h4 id="关于存储"><a href="#关于存储" class="headerlink" title="关于存储"></a>关于存储</h4><ul>
<li>插入图片、pfd、视频最好使用在线资源，这样并不占用github空间。我使用的是七牛云存储。免费存储，配置域名，可以获得文件的公开url。唯一就是限制访问流量大约1G左右。付费100G 一年 19￥。</li>
</ul>
<h4 id="显示滚动百分比"><a href="#显示滚动百分比" class="headerlink" title="显示滚动百分比"></a>显示滚动百分比</h4><ul>
<li>主题配置文件 修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b2t: false</span><br></pre></td></tr></table></figure>

<h4 id="配置侧边栏位置和显示时机"><a href="#配置侧边栏位置和显示时机" class="headerlink" title="配置侧边栏位置和显示时机"></a>配置侧边栏位置和显示时机</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Manual define the sidebar width.</span><br><span class="line">  # If commented, will be default for:</span><br><span class="line">  # Muse | Mist: 320</span><br><span class="line">  # Pisces | Gemini: 240</span><br><span class="line">  #width: 300</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">  display: post</span><br><span class="line">  #display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12</span><br><span class="line"></span><br><span class="line">  # Back to top in sidebar (only for Pisces | Gemini).</span><br><span class="line">  b2t: false</span><br><span class="line"></span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line"></span><br><span class="line">  # Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">  onmobile: false</span><br></pre></td></tr></table></figure>

<h4 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h4><ul>
<li>背景音乐刷新会被重置，并且播放音乐不切换头像</li>
<li>评论系统的评论有可能会被墙掉</li>
<li>文章发布上去UI会有变化</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>QlikView基础使用</title>
    <url>/2021/04/09/QlikView/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍QlikView的基础使用。包括下载安装、配置ODBC数据源、根据数据简单拖拉报表、数据源导入、导出QVD文件等。附加实战项目DEMO的用户手册，简单介绍Qlikview报表的使用和基础功能。</p>
</blockquote>
<span id="more"></span>

<h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4>

	<div class="row">
    <embed src="./QlikView.pdf" width="100%" height="550" type="application/pdf">
	</div>




<h4 id="demo"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4>

	<div class="row">
    <embed src="./MenariniQlikview.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>BI</category>
      </categories>
      <tags>
        <tag>QlikView</tag>
      </tags>
  </entry>
  <entry>
    <title>RPA</title>
    <url>/2021/04/10/RPA/</url>
    <content><![CDATA[<blockquote>
<p>RPA:机器人流程自动化系统，通过模拟用户在电脑上的手动操作，实现某种操作流程的自动化。本文是一个简单例子：自动登录网址，并截图报错本地，再发送到指定邮箱中。Python实现。</p>
</blockquote>
<span id="more"></span>

<h4 id="登录网址截图保存到本地"><a href="#登录网址截图保存到本地" class="headerlink" title="登录网址截图保存到本地"></a>登录网址截图保存到本地</h4><figure class="highlight python"><figcaption><span>code here</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver =webdriver.Chrome()</span><br><span class="line"><span class="comment">## executable_path=&#x27;C:\workspace\RPA\chromedriver.exe&#x27;</span></span><br><span class="line"><span class="comment">## 设置窗口大小</span></span><br><span class="line"><span class="comment">#全屏</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line"><span class="comment">## 访问地址 https://agn-xlab.idata.mobi/user/login</span></span><br><span class="line">url=<span class="string">&#x27;https://agn-xlab.idata.mobi/user/login&#x27;</span></span><br><span class="line"></span><br><span class="line">driver.get(url=url)</span><br><span class="line"><span class="comment">## 设置等待阈值</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment">## 登录</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;okta-signin-username&#x27;</span>).send_keys(<span class="string">&#x27;JLi011&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;okta-signin-password&#x27;</span>).send_keys(<span class="string">&#x27;Allergan1&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;okta-signin-submit&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 设置等待阈值</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment">## 登录okta</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;input10&#x27;</span>).send_keys(<span class="string">&#x27;科比布莱恩特&#x27;</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;form8&quot;]/div[2]/input&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 九宫格</span></span><br><span class="line"><span class="comment">## driver.find_element_by_xpath(&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[1]/div&#x27;).click()</span></span><br><span class="line"><span class="comment">#driver.find_element_by_xpath(&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[1]/ul/li/div&#x27;).click()</span></span><br><span class="line"><span class="comment">#driver.find_element_by_xpath(&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[1]/ul/li/ul/li&#x27;).click()</span></span><br><span class="line"><span class="comment">#driver.implicitly_wait(30)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 医生主题域</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[3]/div&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[3]/ul/li[1]/div[1]&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[1]/div/ul/li[3]/ul/li[1]/ul/li&#x27;</span>).click()</span><br><span class="line"><span class="comment">## 隐藏菜单栏</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div/i&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment">## 截屏</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">u&quot;C:\\Users\\admin\\Pictures\\xlab\\doctor.png&quot;</span>)</span><br><span class="line"><span class="comment">## 获取当前页面URL地址</span></span><br><span class="line"><span class="comment">## url01 = driver.current_url</span></span><br><span class="line"><span class="comment"># driver.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="登录邮箱将截图发送出去"><a href="#登录邮箱将截图发送出去" class="headerlink" title="登录邮箱将截图发送出去"></a>登录邮箱将截图发送出去</h4><figure class="highlight python"><figcaption><span>code here</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver =webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## executable_path=&#x27;C:\workspace\RPA\chromedriver.exe&#x27;</span></span><br><span class="line"><span class="comment">## 设置窗口大小</span></span><br><span class="line"><span class="comment">#全屏</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line">url=<span class="string">&#x27;https://login.partner.microsoftonline.cn/&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.get(url=url)</span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录邮箱</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;i0116&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;power_bi@intfocus.com&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;idSIButton9&#x27;</span>).click()</span><br><span class="line">driver.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;i0118&#x27;</span>).send_keys(<span class="string">&#x27;PowerBI666&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;idSIButton9&#x27;</span>).click()</span><br><span class="line">driver.implicitly_wait(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;idSIButton9&#x27;</span>).click()</span><br><span class="line">driver.implicitly_wait(<span class="number">3</span>)</span><br><span class="line"><span class="comment">## 进入邮箱</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;ShellMail_link&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment">## 新建邮件</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[1]/div/div/div/div/div[1]/div[1]/button&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[2]/div/div[3]/div[1]/div/div/div/div[1]/div[1]/div[1]/div[1]/div[1]/div/div/div/div/div[1]/div/div/input&#x27;</span>).send_keys(<span class="string">&#x27;wenbin.que@intfocus.com&#x27;</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[2]/div/div[3]/div[1]/div/div/div/div[1]/div[1]/div[1]/div[2]/div/div/div/div/div/div[1]/div/div/input&#x27;</span>).send_keys(<span class="string">&#x27;ben.wang@intfocus.com &#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;TextField957&#x27;</span>).send_keys(<span class="string">&#x27;RPA 自动化测试&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">context= <span class="string">&quot;Dear all，\n xlab实验室RAP自动化监控测试\n 医生主数据：\n&quot;</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[2]/div/div[3]/div[1]/div/div/div/div[1]/div[2]/div[1]&#x27;</span>).send_keys(context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[2]/div/div[3]/div[1]/div/div/div/div[1]/div[3]/div[2]/div[2]/div/div/div/div/div[2]/div/div/button&#x27;</span>).click()<span class="comment">#send_keys(&#x27;C:\\Users\\admin\\Pictures\\xlab\\doctor.png&#x27;)</span></span><br><span class="line">time.sleep(<span class="number">3</span>)  <span class="comment"># 一定要加，弹出框后才有后续上传，之前因为没写弹窗没出后续执行无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># win32gui 操作系统选择文件的窗口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    dialog = win32gui.FindWindow(<span class="string">&quot;#32770&quot;</span>,<span class="string">&quot;打开&quot;</span>)  <span class="comment">#一级窗口#如果是其它的浏览器，可能需要改第二个参数，谷歌叫打开</span></span><br><span class="line">    ComboBoxEx32 = win32gui.FindWindowEx(dialog,<span class="number">0</span>,<span class="string">&quot;ComboBoxEx32&quot;</span>,<span class="literal">None</span>)  <span class="comment">#二级</span></span><br><span class="line">    ComboBox = win32gui.FindWindowEx(ComboBoxEx32,<span class="number">0</span>,<span class="string">&quot;ComboBox&quot;</span>,<span class="literal">None</span>)  <span class="comment">#三级</span></span><br><span class="line">    <span class="comment">#路径输入</span></span><br><span class="line">    edit = win32gui.FindWindowEx(ComboBox,<span class="number">0</span>,<span class="string">&quot;Edit&quot;</span>,<span class="literal">None</span>)  <span class="comment">#四级</span></span><br><span class="line">    <span class="comment">#打开按钮</span></span><br><span class="line">    button = win32gui.FindWindowEx(dialog,<span class="number">0</span>,<span class="string">&quot;Button&quot;</span>,<span class="string">&quot;打开(&amp;O)&quot;</span>)  <span class="comment">#二级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#filepath = &quot;D:\\appium_server.log&quot;</span></span><br><span class="line">    <span class="comment">#输入路径</span></span><br><span class="line">    <span class="comment">#点击打开按钮</span></span><br><span class="line">    win32gui.SendMessage(edit,win32con.WM_SETTEXT,<span class="literal">None</span>,filepath)    <span class="comment">#发送文件路径</span></span><br><span class="line">    win32gui.SendMessage(dialog, win32con.WM_COMMAND, <span class="number">1</span>, button)    <span class="comment">#点击打开按钮</span></span><br><span class="line"></span><br><span class="line">upload(<span class="string">&quot;C:\\Users\\admin\\Pictures\\xlab\\doctor.png&quot;</span>)</span><br><span class="line"><span class="comment">## 发送文件</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[2]/div[1]/div/div[3]/div[2]/div/div[3]/div[1]/div/div/div/div[1]/div[3]/div[2]/div[1]/div/span/button[1]&#x27;</span>).click()<span class="comment">#send_keys(&#x27;C:\\Users\\admin\\Pictures\\xlab\\doctor.png&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#driver.implicitly_wait(5)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>RPA,python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL基础</title>
    <url>/2021/04/07/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍数据库SQL基础语法及相应函数。包含表的增删改查。</p>
</blockquote>
<span id="more"></span>

<h4 id="1创建表语句"><a href="#1-创建表语句" class="headerlink" title="1.创建表语句"></a>1.创建表语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table if not exists 表名 (</span><br><span class="line">    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,-- not null 非空约束；primary key 主键；auto_increment 自增</span><br><span class="line">    name VARCHAR(50) NOT NULL,</span><br><span class="line">    birth_date DATE,</span><br><span class="line">    sex varchar(4) default &#39;男&#39;, -- default 默认约束</span><br><span class="line">    phone VARCHAR(15) NOT NULL UNIQUE -- unique 唯一性约束</span><br><span class="line">    -- primary key (id) 主键定义也可写在后面</span><br><span class="line">    -- 外键约束：constraint 外键名 foreign key (字段名) references 主表名(主键列)  </span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 DEFAULT CHARSET&#x3D;utf8; </span><br><span class="line">-- engin 存储引擎；auto_increment&#x3D;0主键自增从0开始；dedault charset&#x3D;utf8 默认编码格式utf8</span><br></pre></td></tr></table></figure>

<h4 id="2避免在索引上使用计算"><a href="#2-避免在索引上使用计算" class="headerlink" title="2.避免在索引上使用计算"></a>2.避免在索引上使用计算</h4>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发</title>
    <url>/2021/04/10/android%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="pdf.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>引用pdf测试</title>
    <url>/2021/04/04/book/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="QlikView.pdf" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
  </entry>
  <entry>
    <title>infocus入职培训</title>
    <url>/2021/04/09/%E5%85%A5%E8%81%8C%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍QlikView的基础使用。包括下载安装、配置ODBC数据源、根据数据简单拖拉报表、数据源导入、导出QVD文件等</p>
</blockquote>
<span id="more"></span>



	<div class="row">
    <embed src="./ruzhipeixun.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程</title>
    <url>/2021/04/07/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍存储过程相关知识。主要介绍存储过程优点、概念、分类、创建存储过程、存储过程中使用到的代码块、存储过程与函数区别等。供借鉴学习。</p>
</blockquote>
<span id="more"></span>

<h4 id="1存储过程概念及分类"><a href="#1-存储过程概念及分类" class="headerlink" title="1.存储过程概念及分类"></a>1.存储过程概念及分类</h4><ul>
<li>概念：存储过程(stored procedure)是一组为了完成特定功能的SQL语句集合，经编译后存储在服务器端的数据库中，利用存储过程可以加速SQL语句的执行。</li>
<li>分类：系统存储过程和自定义存储过程。</li>
</ul>
<h4 id="2存储过程优点"><a href="#2-存储过程优点" class="headerlink" title="2.存储过程优点"></a>2.存储过程优点</h4><ul>
<li>提高应用程序的通用性和可移植性：存储过程创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。并且数据库专业人员可以随时对存储过程进行修改，且对程序源代码没有影响，这样就极大的提高了程序的可移植性。</li>
<li>可以更有效的管理用户操作数据库的权限：在Sql Server数据库中，系统管理员可以通过对执行某一存储过程的权限进行限制，从而实现对相应的数据访问进行控制，避免非授权用户对数据库的访问，保证数据的安全。</li>
<li>可以提高SQL的速度：存储过程是编译过的，如果某一个操作包含大量的SQL代码或分别被执行多次，那么使用存储过程比直接使用单条SQL语句执行速度快的多。</li>
<li>减轻服务器的负担：当用户的操作是针对数据库对象的操作时，如果使用单条调用的方式，那么网络上还必须传输大量的SQL语句，如果使用存储过程，则直接发送过程的调用命令即可，降低了网络的负担。</li>
</ul>
<h4 id="1创建存储过程"><a href="#1-创建存储过程" class="headerlink" title="1.创建存储过程"></a>1.创建存储过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure if exists &#96;存储过程名&#96;;</span><br><span class="line">delimiter ;;</span><br><span class="line">create procedure &#96;存储过程名&#96;(IN MaterNum char(30),... (参数))</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<h4 id="2-调用存储过程"><a href="#2-调用存储过程" class="headerlink" title="2. 调用存储过程"></a>2. 调用存储过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(参数); </span><br></pre></td></tr></table></figure>

<h4 id="3常用代码块"><a href="#3-常用代码块" class="headerlink" title="3.常用代码块"></a>3.常用代码块</h4><ul>
<li>CASE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">	WHEN when_value THEN</span><br><span class="line">		statement_list</span><br><span class="line">	ELSE</span><br><span class="line">		statement_list</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<ul>
<li>IF…ELSE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF search_condition THEN</span><br><span class="line">	statement_list</span><br><span class="line">ELSE</span><br><span class="line">	statement_list</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHILE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHILE search_condition DO</span><br><span class="line">	statement_list</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>

<ul>
<li>LOOP</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label: LOOP</span><br><span class="line">	statement_list</span><br><span class="line"></span><br><span class="line">	IF exit_condition THEN</span><br><span class="line">		LEAVE label; </span><br><span class="line">	END IF; </span><br><span class="line">END LOOP label;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的SQL场景</title>
    <url>/2021/04/09/%E5%B8%B8%E7%94%A8sql%E6%83%85%E6%99%AF/</url>
    <content><![CDATA[<blockquote>
<p>主要介绍在写SQL过程中，经常遇到的场景。包含系统表的使用，查询表字段、注释、大小，行转列，列转行，多行数据合并一行，一行拆分多行、实现累加等多个场景。</p>
</blockquote>
<span id="more"></span>

<h4 id="1将查询数据导入已有表中"><a href="#1-将查询数据导入已有表中" class="headerlink" title="1.将查询数据导入已有表中"></a>1.将查询数据导入已有表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename</span><br></pre></td></tr></table></figure>

<h4 id="2将查询数据导入新表中"><a href="#2-将查询数据导入新表中" class="headerlink" title="2.将查询数据导入新表中"></a>2.将查询数据导入新表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rds_rep_practice_describle_v2 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">*</span>  <span class="keyword">from</span>  rds_rep_practice_describle <span class="keyword">group</span> <span class="keyword">by</span> concat(rep_id,item03)</span><br></pre></td></tr></table></figure>

<h4 id="3去除字符串中间的空格"><a href="#3-去除字符串中间的空格" class="headerlink" title="3.去除字符串中间的空格"></a>3.<strong>去除字符串中间的空格</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE(<span class="string">&#x27;ababab&#x27;</span>,<span class="string">&#x27;abab&#x27;</span>,<span class="string">&#x27;12&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;12ab&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4根据逗号拆分数据分一行为多行"><a href="#4-根据逗号拆分数据分一行为多行" class="headerlink" title="4.根据逗号拆分数据分一行为多行"></a>4.根据逗号拆分数据分一行为多行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql 根据逗号拆分一行数据为多行,help_top表的help_topic_id 从0 开始</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.member_uuid,</span><br><span class="line">    substring_index(substring_index( a.member_role_name, <span class="string">&#x27;,&#x27;</span>, b.id <span class="operator">+</span> <span class="number">1</span> ), <span class="string">&#x27;,&#x27;</span>,<span class="operator">-</span> <span class="number">1</span> ) <span class="keyword">AS</span> member_role_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    fyk_new_upload_members_tds a</span><br><span class="line"><span class="keyword">JOIN</span> help_top b</span><br><span class="line"><span class="keyword">ON</span> b.id <span class="operator">&lt;</span> ( length( a.member_role_name ) <span class="operator">-</span> length( REPLACE ( a.member_role_name, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span> ) ) <span class="operator">+</span> <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span>&quot;abc,ad,cd&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (item)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">SUBSTRING_INDEX(SUBSTRING_INDEX(<span class="variable">@name</span>,<span class="string">&#x27;,&#x27;</span>,help_topic_id<span class="operator">+</span><span class="number">1</span>),<span class="string">&#x27;,&#x27;</span>,<span class="number">-1</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">mysql.help_topic</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">help_topic_id <span class="operator">&lt;</span> LENGTH(<span class="variable">@name</span>)<span class="operator">-</span>LENGTH(REPLACE(<span class="variable">@name</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h4 id="5hive-根据多个字段去重"><a href="#5-Hive-根据多个字段去重" class="headerlink" title="5.Hive 根据多个字段去重"></a>5.<strong>Hive 根据多个字段去重</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- hive 根据多个字段去重</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> T.<span class="operator">*</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> hcp_veeva_id,hcp_doctor_name,hcp_doctor_hospital <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>) RN</span><br><span class="line"><span class="keyword">FROM</span> NS_Allergan_Xlab.hcp_doctor_360_target_rds T <span class="keyword">where</span> ds<span class="operator">=</span><span class="string">&#x27;$&#123;dt&#125;&#x27;</span></span><br><span class="line">) A</span><br><span class="line"><span class="keyword">WHERE</span> A.RN<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6mysql-设置变量参与循环"><a href="#6-mysql-设置变量参与循环" class="headerlink" title="6.mysql 设置变量参与循环"></a>6.<strong>mysql 设置变量参与循环</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql 设置变量参与循环</span></span><br><span class="line">while <span class="variable">@i</span><span class="operator">&lt;=</span><span class="variable">@num</span> DO</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@i</span><span class="operator">=</span><span class="variable">@i</span><span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7mysql-group_concat用法"><a href="#7-mysql-group-concat-用法" class="headerlink" title="7.mysql group_concat()用法"></a>7.mysql group_concat()用法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</span></span><br><span class="line">语法：group_concat( [<span class="keyword">distinct</span>] 要连接的字段 [<span class="keyword">order</span> <span class="keyword">by</span> 排序字段 <span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>  ] [separator <span class="string">&#x27;分隔符&#x27;</span>] )</span><br><span class="line">例子：<span class="keyword">select</span> name, group_concat(id) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<h4 id="8mysql-查看表的最后更新时间"><a href="#8-MySQL-查看表的最后更新时间" class="headerlink" title="8.MySQL 查看表的最后更新时间"></a>8.MySQL <strong>查看表的最后更新时间</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表的最后更新时间</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    `TABLE_NAME`, `UPDATE_TIME`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `information_schema`.`TABLES`</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    `information_schema`.`TABLES`.`TABLE_SCHEMA` <span class="operator">=</span> <span class="string">&#x27;ieipdb2&#x27;</span></span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line">    `information_schema`.`TABLES`.`TABLE_NAME` <span class="operator">=</span> <span class="string">&#x27;s_index_report&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="9mysql-查询一个的字段及注释"><a href="#9-MySQL-查询一个的字段及注释" class="headerlink" title="9.MySQL 查询一个的字段及注释"></a>9.MySQL 查询一个的字段及注释</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询一个表的所有列名，字段的注释</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    TABLE_NAME,</span><br><span class="line">    COLUMN_NAME,</span><br><span class="line">    COLUMN_TYPE,</span><br><span class="line">    COLUMN_COMMENT</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema. COLUMNS</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_schema <span class="operator">=</span> <span class="string">&#x27;allergan_sales_ab&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> table_name <span class="operator">=</span> <span class="string">&#x27;ods_direction_xlab&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="10mysql查询一个表的所有列名数据类型"><a href="#10-MySQL查询一个表的所有列名，数据类型" class="headerlink" title="10.MySQL查询一个表的所有列名，数据类型"></a>10.MySQL<strong>查询一个表的所有列名，数据类型</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询一个表的所有列名，数据类型</span></span><br><span class="line"><span class="keyword">select</span> column_name,data_type <span class="keyword">from</span> information_schema.columns</span><br><span class="line"><span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;Sys_User&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="11根据b表数据更新a表数据"><a href="#11-根据b表数据更新A表数据" class="headerlink" title="11.根据b表数据更新A表数据"></a>11.<strong>根据b表数据更新A表数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update 表A <span class="keyword">as</span> a ,表B <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">set</span> a.role_id<span class="operator">=</span>b.set_value</span><br><span class="line"><span class="keyword">where</span> a.role_id<span class="operator">=</span>b.set_key</span><br></pre></td></tr></table></figure>

<h4 id="12mysql查询表注释"><a href="#12-MySQL查询表注释" class="headerlink" title="12.MySQL查询表注释"></a>12.MySQL<strong>查询表注释</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">table_name ,</span><br><span class="line">table_comment</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">table_schema <span class="operator">=</span> <span class="string">&#x27;allergan_sales_ab&#x27;</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">left</span>(TABLE_NAME,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;ods&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">table_name;</span><br></pre></td></tr></table></figure>

<h4 id="13-查看表的大小"><a href="#13-查看表的大小" class="headerlink" title="13. 查看表的大小"></a>13. <strong>查看表的大小</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;G&#x27;</span>) <span class="keyword">as</span> data <span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;allergan_sales_ab&#x27;</span> <span class="keyword">and</span> table_name <span class="operator">=</span> <span class="string">&#x27;tblcrm_doccall_detail_veeva&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="14查询字段在哪个表中"><a href="#14-查询字段在哪个表中" class="headerlink" title="14.查询字段在哪个表中"></a>14.查询字段在哪个表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema ,table_name   <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> column_name <span class="operator">=</span> <span class="string">&#x27;comparison_approval_status&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="15mysql实现累加"><a href="#15-MySQL实现累加" class="headerlink" title="15.MySQL实现累加"></a>15.MySQL实现累加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@csum</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> 日期, 净利润, (<span class="variable">@csum</span> :<span class="operator">=</span> <span class="variable">@csum</span> <span class="operator">+</span> 净利润) <span class="keyword">AS</span> 累计利润</span><br><span class="line"><span class="keyword">FROM</span> daily_pnl_view</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 日期</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 日期;</span><br></pre></td></tr></table></figure>

<h4 id="16行转列-列转行"><a href="#16-行转列、列转行" class="headerlink" title="16.行转列、列转行"></a>16.行转列、列转行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建测试表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_score;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_score(</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    userid <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    subject <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT <span class="string">&#x27;科目&#x27;</span>,</span><br><span class="line">    score <span class="keyword">DOUBLE</span> COMMENT <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">92</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">75.5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">85</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;政治&#x27;</span>,<span class="number">82</span>);</span><br><span class="line"><span class="comment">-- 行转列 </span></span><br><span class="line">	<span class="comment">-- 1.利用case when then 进行行转列 或 if </span></span><br><span class="line"><span class="keyword">SELECT</span> userid,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `subject` <span class="keyword">WHEN</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `subject` <span class="keyword">WHEN</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `subject` <span class="keyword">WHEN</span> <span class="string">&#x27;英语&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `subject` <span class="keyword">WHEN</span> <span class="string">&#x27;政治&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">&#x27;政治&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> tb_score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userid;</span><br><span class="line">	<span class="comment">-- 2.left join 自关联做限制	</span></span><br><span class="line"><span class="keyword">select</span> t1.userid,</span><br><span class="line">t1.score <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line">t2.score <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">t3.score <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">t4.score <span class="keyword">as</span> <span class="string">&#x27;政治&#x27;</span></span><br><span class="line"><span class="keyword">from</span> tb_score t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_score t2 <span class="keyword">on</span> t1.userid <span class="operator">=</span>t2.userid <span class="keyword">and</span> t2.subject <span class="operator">=</span><span class="string">&#x27;数学&#x27;</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_score t3 <span class="keyword">on</span> t1.userid<span class="operator">=</span>t3.userid <span class="keyword">and</span> t3.subject <span class="operator">=</span><span class="string">&#x27;英语&#x27;</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_score t4 <span class="keyword">on</span> t1.userid<span class="operator">=</span>t4.userid <span class="keyword">and</span> t4.subject <span class="operator">=</span><span class="string">&#x27;政治&#x27;</span></span><br><span class="line"><span class="keyword">where</span> t1.subject<span class="operator">=</span><span class="string">&#x27;语文&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> t1.userid;</span><br><span class="line"><span class="comment">-- 列转行。union all 查询每个tag的数据，然后union all和并起来</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>工作总结</title>
    <url>/2021/04/09/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>在上海工作了一年2020年3月到2021年3月。人数第一份正式工作感慨很多，也学到了很多。记录下来总结一下，给第一份工作画个句号。包含：对自己职业发展路线的思考以及工作方法的总结。</p>
</blockquote>
<span id="more"></span>

<h3 id="职业发展路线"><a href="#职业发展路线" class="headerlink" title="职业发展路线"></a>职业发展路线</h3><p>​    我是以Java工程师的角色应招进入公司的。但发生了偏差，实际从事的是数据方面的工作。没有抱怨，毕竟招聘时，也曾聊过可能会串岗。正式工作内容包含 ETL开发、数据开发、BI开发、运维工作。工作初期还是遇到了很多问题，比如Excel不熟练、各种工具都是大学未曾学到的。所以当时学到很着急，感觉自己哪里都不会。工作一年渐渐进入节奏。也渐渐对数据工作有了兴趣。数据作为所有业务的支持，是最低层的、最基础的、最重要的。通过数据可以直观反映一个公司业务的情况、前提是对数据进行采集、抽取、清洗、探查、转换、分析、展现。数据能够最直接地展示它的价值，其它语言及岗位只是对数据结果进行展示和输出。所以为什么不直接从事数据方面的工作呢！</p>
<p>​    职业规划：3年内主要做技术积累，期间积累的不仅仅是技术，更多的是对数据分析的方法、对业务的理解。技术总有办法解决，重要的是如何分析数据、如何将数据与业务连接。3年到5年技术管理层，数据解决方案、数据处理架构。5年后纯管理层或者创业，数据分析决策者</p>
<h3 id="工作方法"><a href="#工作方法" class="headerlink" title="工作方法"></a>工作方法</h3><ul>
<li>文档：先写文档，再执行。先写文档，再执行。先写文档，再执行。写出来才能说出来。</li>
<li>工作边界：划清楚自己当前工作的工作边界，以达到某种目的或状态为止。</li>
<li>清晰：对自己工作范围内的事情要清晰明白，做到心中有把握。对需求要清晰，不懂要问，不能似是而非。</li>
<li>跳出思考：对某一难以解决的问题，要学会跳出固定思维去解决。不能执拗某个点。</li>
<li>沟通：有效的沟通能够了解更多自身知识体系外的知识，且做事情更准确有效。说不出来是应为没有写过。</li>
<li>规范：做东西要符合某一规范，不管是自己的还是企业的，最好是自己的。</li>
<li>总结：项目结果后要学会总结、反思。</li>
<li>通用性：不管是文档还是代码都要留有余地或弹性的空间。</li>
<li>谦逊：保持谦虚的态度，多写、多看、多听。不要眼高手低、多去实践。不低估自己、不高估自己。</li>
<li>闭环思维：思维逻辑要形成通路，考虑周全，自圆其说。不论是交流还是技术。</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL基础</title>
    <url>/2021/04/07/%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍常见的几种开窗函数的用法及区别。包含排序开窗函数和聚合开窗函数。</p>
</blockquote>
<span id="more"></span>

<h4 id="1创建表语句"><a href="#1-创建表语句" class="headerlink" title="1.创建表语句"></a>1.创建表语句</h4><figure class="highlight sql"><figcaption><span>code here</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> 表名 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,<span class="comment">-- not null 非空约束；primary key 主键；auto_increment 自增</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birth_date <span class="type">DATE</span>,</span><br><span class="line">    sex <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span>, <span class="comment">-- default 默认约束</span></span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="comment">-- unique 唯一性约束</span></span><br><span class="line">    <span class="comment">-- primary key (id) 主键定义也可写在后面</span></span><br><span class="line">    <span class="comment">-- 外键约束：constraint 外键名 foreign key (字段名) references 主表名(主键列)  </span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8; </span><br><span class="line"><span class="comment">-- engin 存储引擎；auto_increment=0主键自增从0开始；dedault charset=utf8 默认编码格式utf8</span></span><br></pre></td></tr></table></figure>

<h4 id="2常用的开窗函数"><a href="#2-常用的开窗函数" class="headerlink" title="2.常用的开窗函数"></a>2.常用的开窗函数</h4><ul>
<li><strong>排序开窗函数-分区排序：row_number () over()</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每门课程course_name前三名的学生姓名及成绩，要求输出列格式如下：</span></span><br><span class="line"><span class="comment">-- 表名：student_grades 字段名：course_name, number, stu_name, grades</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(	<span class="keyword">select</span> course_name,</span><br><span class="line">		<span class="built_in">row_number</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> course_name <span class="keyword">order</span> <span class="keyword">by</span> grades <span class="keyword">desc</span>() ) <span class="keyword">as</span> number ,</span><br><span class="line">		stu_name,</span><br><span class="line">		grades</span><br><span class="line">	<span class="keyword">from</span> student_grades</span><br><span class="line">) a <span class="keyword">where</span> a.number<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>聚合开窗函数-count()</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studentId,math,departmentId,classId,</span><br><span class="line"><span class="comment">-- 以符合条件的所有行作为窗口</span></span><br><span class="line"><span class="built_in">count</span>(math) <span class="keyword">over</span>() <span class="keyword">as</span> count1,</span><br><span class="line"><span class="comment">-- 以按classId分组的所有行作为窗口</span></span><br><span class="line"><span class="built_in">count</span>(math) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> classId) <span class="keyword">as</span> count2,</span><br><span class="line"><span class="comment">-- 以按classId分组、按math排序的所有行作为窗口</span></span><br><span class="line"><span class="built_in">count</span>(math) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> classId <span class="keyword">order</span> <span class="keyword">by</span> math) <span class="keyword">as</span> count3,</span><br><span class="line"><span class="comment">-- 以按classId分组、按math排序、按 当前行+往前1行+往后2行的行作为窗口</span></span><br><span class="line"><span class="built_in">count</span>(math) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> classId <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">2</span> following) <span class="keyword">as</span> count4</span><br><span class="line"><span class="keyword">from</span> student_scores <span class="keyword">where</span> departmentId<span class="operator">=</span><span class="string">&#x27;department1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>聚合开窗函数-sum()</strong></p>
</li>
<li><p><strong>聚合开窗函数-min()</strong></p>
</li>
<li><p><strong>聚合开窗函数-max()</strong></p>
</li>
<li><p><strong>聚合开窗函数-avg()</strong></p>
</li>
<li><p><strong>聚合开窗函数-first_value()</strong></p>
</li>
<li><p><strong>聚合开窗函数-last_value()</strong></p>
</li>
<li><p><strong>聚合开窗函数-lag(col,n,default)</strong></p>
</li>
<li><p><strong>聚合开窗函数-lead()</strong></p>
</li>
<li><p><strong>聚合开窗函数-cume_dist()</strong></p>
</li>
</ul>
<h4 id="3几种排序函数区别"><a href="#3-几种排序函数区别" class="headerlink" title="3.几种排序函数区别"></a>3.几种排序函数区别</h4><ul>
<li><p>row_number() over()：对相等的值不进行区分，相等的值对应的排名相同，序号从1到n连续。</p>
</li>
<li><p>rank() over()：相等的值排名相同，但若有相等的值，则序号从1到n不连续。如果有两个人都排在第3名，则没有第4名。</p>
</li>
<li><p>dense_rank() over()：对相等的值排名相同，但序号从1到n连续。如果有两个人都排在第一名，则排在第2名（假设仅有1个第二名）的人是第3个人。</p>
</li>
<li><p>ntile( n ) over()：可以看作是把有序的数据集合平均分配到指定的数量n的桶中,将桶号分配给每一行，排序对应的数字为桶号。如果不能平均分配，则较小桶号的桶分配额外的行，并且各个桶中能放的数据条数最多相差1。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,stu_name,course_name,grades</span><br><span class="line">		<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> grades) <span class="keyword">as</span> row_num,</span><br><span class="line">		<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> grades) <span class="keyword">as</span> rank,</span><br><span class="line">		desen_rank() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> grades) <span class="keyword">as</span> desen_rank,</span><br><span class="line">		<span class="built_in">ntile</span>(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> grades) <span class="keyword">as</span> ntile</span><br><span class="line"><span class="keyword">from</span> student_grades;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>开窗函数</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL优化</title>
    <url>/2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍SQL的调优。SQL调优对项目的性能来讲至关重要,所有掌握常见的SQL调优方式是必不可少的,下面介绍几种常见的SQL的调优方式,供借鉴学习。来源于 CSDN <a href="https://lss0555.blog.csdn.net/">lss0555</a></p>
</blockquote>
<span id="more"></span>

<h4 id="1创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h4><ul>
<li>要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>在经常需要进行检索的字段上创建索引</li>
<li>创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引</li>
<li>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</li>
</ul>
<h4 id="2避免在索引上使用计算"><a href="#2-避免在索引上使用计算" class="headerlink" title="2.避免在索引上使用计算"></a>2.避免在索引上使用计算</h4><p>效率低：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> salary<span class="operator">*</span><span class="number">22</span><span class="operator">&gt;</span><span class="number">11000</span>(salary是索引列)</span><br></pre></td></tr></table></figure>

<p>效率高：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> salary<span class="operator">&gt;</span><span class="number">11000</span><span class="operator">/</span><span class="number">22</span>(salary是索引列)</span><br></pre></td></tr></table></figure>

<h4 id="3使用预编译查询"><a href="#3-使用预编译查询" class="headerlink" title="3.使用预编译查询"></a>3.使用预编译查询</h4><p>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞<br>攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化<br>并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p>
<h4 id="4调整where字句中的连接顺序"><a href="#4-调整Where字句中的连接顺序" class="headerlink" title="4.调整Where字句中的连接顺序"></a>4.调整Where字句中的连接顺序</h4><p>DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以<br>过滤掉最大数量记录。</p>
<h4 id="5尽量将多条sql语句压缩到一句sql中"><a href="#5-尽量将多条SQL语句压缩到一句SQL中" class="headerlink" title="5.尽量将多条SQL语句压缩到一句SQL中"></a>5.尽量将多条SQL语句压缩到一句SQL中</h4><p>每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程<br>是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。</p>
<h4 id="6用where字句替换having字句"><a href="#6-用where字句替换HAVING字句" class="headerlink" title="6.用where字句替换HAVING字句"></a>6.用where字句替换HAVING字句</h4><p>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前<br>刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数<br>的过滤，除此之外，应该将条件写在where字句中。</p>
<h4 id="7使用表的别名"><a href="#7-使用表的别名" class="headerlink" title="7.使用表的别名"></a>7.使用表的别名</h4><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减<br>少哪些友列名歧义引起的语法错误。</p>
<h4 id="8用union-all替换union"><a href="#8-用union-all替换union" class="headerlink" title="8.用union all替换union"></a>8.用union all替换union</h4><p>当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集<br>同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应<br>该用union all，这样效率就会因此得到提高。</p>
<h4 id="9考虑使用临时表暂存中间结果"><a href="#9-考虑使用“临时表”暂存中间结果" class="headerlink" title="9.考虑使用“临时表”暂存中间结果"></a>9.考虑使用“临时表”暂存中间结果</h4><p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。<br>但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<h4 id="10只在必要的情况下才使用事务"><a href="#10-只在必要的情况下才使用事务" class="headerlink" title="10.只在必要的情况下才使用事务"></a>10.只在必要的情况下才使用事务</h4><p>SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。<br>有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。<br>可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。<br>Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin translation。</p>
<h4 id="11尽量避免使用游标"><a href="#11-尽量避免使用游标" class="headerlink" title="11.尽量避免使用游标"></a>11.尽量避免使用游标</h4><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<h4 id="12用varcharnvarchar-代替-charnchar"><a href="#12-用varchar-nvarchar-代替-char-nchar" class="headerlink" title="12.用varchar/nvarchar 代替 char/nchar"></a>12.用varchar/nvarchar 代替 char/nchar</h4><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p>
<h4 id="13查询select语句优化"><a href="#13-查询select语句优化" class="headerlink" title="13.查询select语句优化"></a>13.查询select语句优化</h4><p>1.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段<br>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，<br>如：</p>
<pre><code> select id from t where num is null      
</code></pre>
<p>可以在num上设置默认值0，确保表中num列没有null值，<br>然后这样查询：</p>
<pre><code>  select id from t where num=0
  select id from t where num=10 or num=20```
</code></pre>
<p>可以这样查询：</p>
<pre><code>  select id from t where num=10
   union all
  select id from t where num=20```
</code></pre>
<p>4.不能前置百分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> ‘<span class="operator">%</span>abc<span class="operator">%</span>’</span><br></pre></td></tr></table></figure>
<p>若要提高效率，可以考虑全文检索。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>5.对于连续的数值，能用 between 就不要用 in 了：</p>
<p>   select id from t where num between 1 and 3<br>6.如果查询的两个表大小相当，那么用in和exists差别不大。<br>例如：表A（小表），表B（大表）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> B) 效率低，用到了A表上cc列的索引；     </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> B <span class="keyword">where</span> cc<span class="operator">=</span>A.cc)   效率高，用到了B表上cc列的索引。   </span><br></pre></td></tr></table></figure>

<p>相反的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> A)  效率高，用到了B表上cc列的索引；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> A <span class="keyword">where</span> cc<span class="operator">=</span>B.cc)  效率低，用到了A表上cc列的索引。</span><br></pre></td></tr></table></figure>

<h4 id="14更新update语句优化"><a href="#14-更新Update语句优化" class="headerlink" title="14.更新Update语句优化"></a>14.更新Update语句优化</h4><p>如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
<h4 id="15插入insert语句优化"><a href="#15-插入Insert语句优化" class="headerlink" title="15.插入Insert语句优化"></a>15.插入Insert语句优化</h4><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据开发面试笔试题</title>
    <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍我在面试数据开发岗和ETL工程师时遇得到的面试题及笔试题。</p>
</blockquote>
<span id="more"></span>

<h4 id="1表a结构如下"><a href="#1-表A结构如下：" class="headerlink" title="1.表A结构如下："></a>1.表A结构如下：</h4><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>wrcvdate</td>
<td>int</td>
<td>日期</td>
<td>主健</td>
</tr>
<tr>
<td>year</td>
<td>int</td>
<td>年</td>
<td></td>
</tr>
<tr>
<td>month</td>
<td>int</td>
<td>月</td>
<td></td>
</tr>
<tr>
<td>day</td>
<td>int</td>
<td>日</td>
<td></td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>工作日标记</td>
<td>1表示工作日，0表示非工作日</td>
</tr>
</tbody></table>
<p>要求编写SQL语句查询20061231对应的上一工作日日期。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  wrcvdate</span><br><span class="line"><span class="keyword">FROM</span>    A</span><br><span class="line"><span class="keyword">WHERE</span>   wrcvdate <span class="operator">&lt;</span><span class="number">20061231</span> <span class="keyword">AND</span> flag <span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> wrcvdate <span class="keyword">DESC</span> LIMIT   <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2表b结构如下"><a href="#2-表B结构如下" class="headerlink" title="2.表B结构如下"></a>2.表B结构如下</h4><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>company</td>
<td>varchar(10)</td>
<td>公司名称</td>
<td></td>
</tr>
<tr>
<td>agencyid</td>
<td>varchar(10)</td>
<td>员工工号</td>
<td>主健</td>
</tr>
<tr>
<td>productid</td>
<td>varchar(3)</td>
<td>产品代码</td>
<td>主健</td>
</tr>
<tr>
<td>wrcvdate</td>
<td>int</td>
<td>日期</td>
<td></td>
</tr>
<tr>
<td>amt</td>
<td>decimal(17,6)</td>
<td>销售金额</td>
<td></td>
</tr>
</tbody></table>
<p>要求编写SQL语句查询2006年8月1日～31日每一天的当月累计销售金额。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用变量累加</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@sum</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span>  wrcvdate</span><br><span class="line">        ,(<span class="variable">@sum</span> :<span class="operator">=</span> <span class="variable">@sum</span><span class="operator">+</span>amt)</span><br><span class="line"><span class="keyword">FROM</span>    B</span><br><span class="line"><span class="keyword">WHERE</span>   wrcvdate <span class="operator">&gt;=</span> <span class="number">20060801</span></span><br><span class="line"><span class="keyword">AND</span>     wrcvdate <span class="operator">&lt;=</span> <span class="number">20060831</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> wrcvdate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> wrcvdate;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自连接 a.日期&gt;=b.日期 就求sum(amt)</span></span><br><span class="line"><span class="keyword">SELECT</span>  t1.wrcvdate</span><br><span class="line">        ,<span class="built_in">sum</span>(t1.amt)</span><br><span class="line"><span class="keyword">FROM</span>    (</span><br><span class="line">            <span class="keyword">SELECT</span>  wrcvdate</span><br><span class="line">                    ,amt</span><br><span class="line">            <span class="keyword">FROM</span>    B</span><br><span class="line">        ) t1</span><br><span class="line"><span class="keyword">JOIN</span>    B t2</span><br><span class="line"><span class="keyword">ON</span>      t1.wrcvdate <span class="operator">&gt;=</span> t2.wrcvdate</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> wrcvdate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> wrcvdate;</span><br></pre></td></tr></table></figure>

<h4 id="3表c结构如下"><a href="#3-表C结构如下" class="headerlink" title="3.表C结构如下"></a>3.表C结构如下</h4><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>company</td>
<td>varchar(10)</td>
<td>公司名称</td>
<td>主健</td>
</tr>
<tr>
<td>agencyid</td>
<td>varchar(10)</td>
<td>员工工号</td>
<td>主健</td>
</tr>
<tr>
<td>orderno</td>
<td>varchar(8)</td>
<td>订单号</td>
<td>主健</td>
</tr>
<tr>
<td>productid</td>
<td>varchar(3)</td>
<td>产品代码</td>
<td>主健</td>
</tr>
<tr>
<td>producttype1</td>
<td>varchar(2)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>producttype2</td>
<td>varchar(2)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>要求编写SQL语句查询(company, agencyid, orderno)组合键值重复的记录明细.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 组合键合成一个字段</span></span><br><span class="line"><span class="keyword">SELECT</span>  a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">                    ,concat( company, agencyid, orderno ) <span class="keyword">AS</span> cao</span><br><span class="line">            <span class="keyword">FROM</span>    C</span><br><span class="line">        ) a</span><br><span class="line"><span class="keyword">JOIN</span>    (</span><br><span class="line">            <span class="comment">-- 查询重复的数据</span></span><br><span class="line">            <span class="keyword">SELECT</span>  concat( company, agencyid, orderno ) <span class="keyword">AS</span> cao</span><br><span class="line">            <span class="keyword">FROM</span>    C</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> concat( company, agencyid, orderno )</span><br><span class="line">            <span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>( concat( company, agencyid, orderno ) ) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">        ) b</span><br><span class="line"><span class="keyword">ON</span>      a.cao <span class="operator">=</span> b.cao;</span><br></pre></td></tr></table></figure>

<h4 id="4表d结构如下"><a href="#4-表D结构如下" class="headerlink" title="4.表D结构如下"></a>4.表D结构如下</h4><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>company</td>
<td>varchar(10)</td>
<td>公司名称</td>
<td>主健</td>
</tr>
<tr>
<td>agencyid</td>
<td>varchar(10)</td>
<td>员工工号</td>
<td>主健</td>
</tr>
<tr>
<td>name</td>
<td>varchar(20)</td>
<td>员工姓名</td>
<td></td>
</tr>
<tr>
<td>dtmonth</td>
<td>int</td>
<td>年月</td>
<td>主健</td>
</tr>
<tr>
<td>duty</td>
<td>varchar(20)</td>
<td>员工职级</td>
<td></td>
</tr>
</tbody></table>
<p>表E结构如下：</p>
<table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>province</td>
<td>varchar(20)</td>
<td>省份</td>
<td></td>
</tr>
<tr>
<td>company</td>
<td>varchar(10)</td>
<td>公司名称</td>
<td>主健</td>
</tr>
<tr>
<td>adearea</td>
<td>varchar(8)</td>
<td>办事处名称</td>
<td>主健</td>
</tr>
</tbody></table>
<p>表D与表E通过company关联，要求编写SQL语句查询每个员工工号所属的省份。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  D.agencyid</span><br><span class="line">        ,D.company</span><br><span class="line">        ,E.province</span><br><span class="line"><span class="keyword">FROM</span>    D</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> E</span><br><span class="line"><span class="keyword">ON</span>      D.company <span class="operator">=</span> E.company;</span><br></pre></td></tr></table></figure>

<h4 id="5表f结构如下"><a href="#5-表F结构如下" class="headerlink" title="5.表F结构如下"></a>5.表F结构如下</h4><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>中文描述</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>company</td>
<td>varchar(10)</td>
<td>公司名称</td>
<td>主健</td>
</tr>
<tr>
<td>agencyid</td>
<td>varchar(10)</td>
<td>员工工号</td>
<td>主健</td>
</tr>
<tr>
<td>orderno</td>
<td>varchar(8)</td>
<td>订单号</td>
<td>主健</td>
</tr>
<tr>
<td>orderdate</td>
<td>int</td>
<td>订单日期</td>
<td></td>
</tr>
<tr>
<td>customer</td>
<td>varchar(10)</td>
<td>客户姓名</td>
<td></td>
</tr>
<tr>
<td>orderstatus</td>
<td>varchar(2)</td>
<td>订单状态</td>
<td></td>
</tr>
<tr>
<td>Ef</td>
<td>datetime</td>
<td>有效起始日期</td>
<td>主健</td>
</tr>
<tr>
<td>Et</td>
<td>datetime</td>
<td>有效结束日期</td>
<td></td>
</tr>
</tbody></table>
<p>  要求编写SQL语句查询<strong>同一订单</strong>的有效起始日期～有效结束日期存在交叉的订单号。下面举例说明：</p>
<table>
<thead>
<tr>
<th><strong>公司名称</strong></th>
<th><strong>员工工号</strong></th>
<th><strong>订单号</strong></th>
<th><strong>订单日期</strong></th>
<th><strong>客户姓名</strong></th>
<th><strong>订单状态</strong></th>
<th><strong>有效起始日期</strong></th>
<th><strong>有效结束日期</strong></th>
</tr>
</thead>
<tbody><tr>
<td>广州分公司</td>
<td>1001</td>
<td>003</td>
<td>20061201</td>
<td>wang</td>
<td>A</td>
<td>1900/1/1</td>
<td>2000/12/20</td>
</tr>
<tr>
<td>广州分公司</td>
<td>1001</td>
<td>003</td>
<td>20070101</td>
<td>wang</td>
<td>B</td>
<td>2000/12/21</td>
<td>9999/12/31</td>
</tr>
<tr>
<td>广州分公司</td>
<td>1001</td>
<td>004</td>
<td>20061201</td>
<td>li</td>
<td>A</td>
<td>1900/1/1</td>
<td>2000/12/20</td>
</tr>
<tr>
<td>广州分公司</td>
<td>1001</td>
<td>004</td>
<td>20070101</td>
<td>li</td>
<td>C</td>
<td>2000/12/20</td>
<td>9999/12/31</td>
</tr>
</tbody></table>
<p>上述第3、4条记录为<strong>同一订单</strong>对应的明细，第三条记录的有效结束日期与第四条记录的有效开始日期出现交叉（2000/12/20），因此订单号 004 就是查询结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对同一个订单，订单日期大的ef应该大于订单日期小的et,反正是异常数据</span></span><br><span class="line"><span class="keyword">SELECT</span>  f1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    (</span><br><span class="line">        <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span>    f</span><br><span class="line">        ) f1</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span>    f</span><br><span class="line">     ) f2</span><br><span class="line"><span class="keyword">ON</span>      f1.orderno <span class="operator">=</span> f2.orderno <span class="keyword">AND</span> f1.orderdate<span class="operator">&gt;</span> f2.orderdate</span><br><span class="line"><span class="keyword">AND</span>     f1.ef<span class="operator">&lt;=</span> f2.et;</span><br></pre></td></tr></table></figure>

<h4 id="6分页查询"><a href="#6-分页查询" class="headerlink" title="6.分页查询"></a>6.分页查询</h4><p>存在表T(a,b,c,d),要根据字段c倒序排列后取第21~30条记录显示，请给出SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    T</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span> LIMIT <span class="number">21</span> ,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7删除表中重复数据"><a href="#7-删除表中重复数据" class="headerlink" title="7.删除表中重复数据"></a>7.删除表中重复数据</h4><p>有一张员工工资表(EMP)，表有两列：员工编号(ID)，工资(SALARY)，请给出SQL删除ID重复的记录，只保留第一条，不需要考虑表中存在完全相同记录的情况。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表，去重数据插入临时表，删除临时表。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp01 <span class="keyword">LIKE</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp01</span><br><span class="line"><span class="keyword">SELECT</span>  id</span><br><span class="line">        ,<span class="built_in">max</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>    emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">TRUNCATE</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    emp01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> emp01;</span><br></pre></td></tr></table></figure>

<h4 id="8行转列"><a href="#8-行转列" class="headerlink" title="8.行转列"></a>8.行转列</h4><p>已知一张表S的结构如左下表，怎样通过select语句把它变成右下表的结构，即将竖表转换为横表。</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>科目</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>语文</td>
<td>20</td>
</tr>
<tr>
<td>张三</td>
<td>数学</td>
<td>30</td>
</tr>
<tr>
<td>张三</td>
<td>英语</td>
<td>50</td>
</tr>
<tr>
<td>李四</td>
<td>语文</td>
<td>70</td>
</tr>
<tr>
<td>李四</td>
<td>数学</td>
<td>60</td>
</tr>
<tr>
<td>李四</td>
<td>英语</td>
<td>90</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>20</td>
<td>30</td>
<td>50</td>
</tr>
<tr>
<td>李四</td>
<td>70</td>
<td>60</td>
<td>90</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	姓名,</span><br><span class="line">	<span class="built_in">sum</span>( <span class="keyword">CASE</span> 科目 <span class="keyword">WHEN</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">THEN</span> 分数 <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line">	<span class="built_in">sum</span>( <span class="keyword">CASE</span> 科目 <span class="keyword">WHEN</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">THEN</span> 分数 <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">	<span class="built_in">sum</span>( <span class="keyword">CASE</span> 科目 <span class="keyword">WHEN</span> <span class="string">&#x27;英语&#x27;</span> <span class="keyword">THEN</span> 分数 <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> <span class="string">&#x27;英语&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	S </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 姓名;</span><br></pre></td></tr></table></figure>

<h4 id="9自连接"><a href="#9-自连接" class="headerlink" title="9.自连接"></a>9.自连接</h4><p>请用SQL 语句实现：从数据表Test中查询出所有月份的发生额都比101 科目相应月份的发生额高的科目。说明：表Test 中有很多科目，都有1~12 月份的发生额，有3个字段， AccID ：科目代码，Occmonth ：发生额月份，DebitOccur ：发生额。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  accid</span><br><span class="line"><span class="keyword">FROM</span>    (</span><br><span class="line">            <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">            <span class="keyword">FROM</span>    test</span><br><span class="line">        ) a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">              <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">              <span class="keyword">FROM</span>    test</span><br><span class="line">              <span class="keyword">WHERE</span>   accid <span class="operator">=</span> <span class="string">&#x27;101&#x27;</span></span><br><span class="line">          ) b</span><br><span class="line"><span class="keyword">ON</span>      a.occmonth <span class="operator">=</span> b.occmonth</span><br><span class="line"><span class="keyword">AND</span>     a.debitoccur <span class="operator">&gt;</span> b.debitoccur;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈、队列、优先队列</title>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h4 id="1-栈stack"><a href="#1、栈（stack）" class="headerlink" title="1、栈（stack）"></a>1、栈（stack）</h4><p>先进后出（后进先出）如图：进栈顺序a-&gt;b-&gt;c,出栈顺序c-&gt;b-&gt;a。</p>
<span id="more"></span>

<p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/15.1.png"></p>
<p>示例代码：Stack1.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//进栈，top先加1再进栈 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">up</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈，先出栈，top再减1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top--; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !top;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前栈大小为：%d\n请输入要进栈的数据以&#x27;0&#x27;结束：&quot;</span>, size());</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">		push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前栈的大小为：%d\n&quot;</span>, size()); </span><br><span class="line">	n = size();</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);<span class="comment">//清空输入缓存</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入1查看栈顶元素，输入2数据依次出栈：&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> tip;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tip);</span><br><span class="line">	<span class="keyword">if</span>(tip == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈顶元素为：%d&quot;</span>,up());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tip == <span class="number">2</span> &amp;&amp; !isEmpty())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;依次出栈：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(j = n - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,up());</span><br><span class="line">			pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n当前栈大小为：%d\n&quot;</span>,size());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-队列queue"><a href="#2、队列（queue）" class="headerlink" title="2、队列（queue）"></a>2、队列（queue）</h4><p>先进先出(先进先出)如图：进队顺序a-&gt;b-&gt;c,出队顺序a-&gt;b-&gt;c。</p>
<p> <img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/15.2.png"></p>
<p>示例代码：queue.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列（queue）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tail=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//进队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>[tail ++] = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，先出队head，再加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	head ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tail - head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == tail) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, n, tip;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队列（queue）\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前队列长度：%d\n请输入要进队列的数据以0结束：&quot;</span>, size());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">		push(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前队列长度：%d\n&quot;</span>,size());</span><br><span class="line">	n = size();</span><br><span class="line"></span><br><span class="line">	fflush(<span class="built_in">stdin</span>);<span class="comment">//清空输入缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n输入1查看队首元素，输入2查看队尾元素，输入3数据依次出队：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tip);</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;抱歉，该队列为空！\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tip == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;队首元素为：%d&quot;</span>, up());</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tip == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;队尾元素为：%d&quot;</span>, <span class="built_in">queue</span>[n<span class="number">-1</span>]);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tip == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;依次出队：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(j = n<span class="number">-1</span>  ; j &gt;= <span class="number">0</span> ; j --) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,up());</span><br><span class="line">				pop();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n当前队列大小为：%d\n&quot;</span>,size());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优先队列priority_queue"><a href="#3、优先队列（priority-queue）" class="headerlink" title="3、优先队列（priority_queue）"></a>3、优先队列（priority_queue）</h4><p>priority_queue本质是一个堆。</p>
<p>Priority_queue的结构：\priority_queue&lt;结构类型&gt; 队列名；</p>
<p>参数：priority_queue&lt;Type, Container, Functional&gt;</p>
<p>Container：是保存数据的容器，Functional是元素比较的方式，Type数据类型，若只写数据类型，容器默认使用vector,比较方式默认使用operator &lt;,就是大顶堆。</p>
<p>基本操作：</p>
<p>q.size();//返回q里元素个数</p>
<p>q.empty();//返回q是否为空，空则返回1，否则返回0</p>
<p>q.push(k);//在q的末尾插入k</p>
<p>q.pop();//删掉q的第一个元素</p>
<p>q.top();//返回q的第一个元素</p>
<p>q.back();//返回q的末尾元素</p>
<p>最常用的结构:</p>
<p>① Priority_queue &lt;数据类型&gt;</p>
<p>② priority_queue <node> q;//node是一个结构体</node></p>
<p>③ priority_queue &lt;int,vector<int>,greater<int> &gt; q;//小顶堆</int></int></p>
<p>④ priority_queue &lt;int,vector<int>,less<int> &gt;q;//大顶堆</int></int></p>
<p>示例代码①：priority_queue1.cpp</p>
<p>示例代码②：priority_queue2.cpp</p>
<p>示例代码③：priority_queue3.cpp</p>
<p>示例代码④：priority_queue3.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	q.push(<span class="number">9</span>);q.push(<span class="number">11</span>);q.push(<span class="number">1</span>);q.push(<span class="number">4</span>);q.push(<span class="number">32</span>);q.push(<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q.top());q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k;</span><br><span class="line"><span class="built_in">priority_queue</span> &lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k.x=<span class="number">10</span>,k.y=<span class="number">100</span>; q.push(k);</span><br><span class="line">    k.x=<span class="number">12</span>,k.y=<span class="number">60</span>; q.push(k);</span><br><span class="line">    k.x=<span class="number">14</span>,k.y=<span class="number">40</span>; q.push(k);</span><br><span class="line">    k.x=<span class="number">6</span>,k.y=<span class="number">80</span>; q.push(k);</span><br><span class="line">    k.x=<span class="number">8</span>,k.y=<span class="number">20</span>; q.push(k);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node m=q.top(); q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,m.x,m.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        p.push(a[i]),q.push(a[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;less&lt;int&gt;:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!p.empty())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p.top()),p.pop();  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ngreater&lt;int&gt;:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q.top()),q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据机构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-Dijkstra</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-Dijkstra/</url>
    <content><![CDATA[<h4 id="dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p><strong>概念：狄克斯特拉算法，计算一个顶点到其余各顶点最短路径的算法。解决有权图中最短路径的问题。此算法基于广度优先搜索，以起始点为中心层层扩展，直至扩展到终点。</strong><span id="more"></span></p>
<p><strong>基本过程：引入一个辅助数组dist[]记录各个点到起始点的距离，开始初始化dist[],定义距离本身的距离为0，起始点下一层的顶点的距离为之间的权值，起始点到不与起始点相邻的顶点距离为无穷大。接着以起始点的下一层顶点向下遍历。目前我的感觉Dijkstra算法就是找出所有起始点到目标点的所有路径，比较出最短的那一条，即起始点到目标点的最短路径。</strong></p>
<p><strong>示例：如图所示的有向带权图</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-Dijkstra/6.1.png" alt="6.1"></p>
<p><strong>假设以v0为起始点求到个点的最短路径。定义辅助数组dist[]，path[]和set[]。path[]主要是记录路径的。Set[]用于标记顶点是否遍历。初始化数据</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dist[]</strong></td>
<td><strong>0</strong></td>
<td><strong>4</strong></td>
<td><strong>6</strong></td>
<td><strong>6</strong></td>
<td><strong>∞</strong></td>
<td><strong>∞</strong></td>
<td><strong>∞</strong></td>
</tr>
<tr>
<td><strong>Path[]</strong></td>
<td><strong>-1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>-1</strong></td>
<td><strong>-1</strong></td>
<td><strong>-1</strong></td>
</tr>
<tr>
<td><strong>Set[]</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody></table>
<p><strong>遍历起始点的下一层，v1到v2的距离为dist(v1,v2)=1，即v2经过v1距离起始点的距离为dist(v0,v1,v2)=5，而5&lt;dist(v0,v2)=6，那么更新数组dist[2]=5，path[2]=1；v1到v4的距离为dist(v1,v4)=7,即dist(v0,v1,v4)=11，更新dist[4]=11，path[4]=1；v1顶点结束，更新set[1]=1；以v2顶点向下遍历，dist(v2,v4)=6,即dist(v0,v1,v2,v4)=11不小于dist(v0,v1,v4)，不更新dist[4]；dist(v2,v5)=4，即dist(v0,v1,v2,v5)=9&lt;dist(v0,v2,v5)=10,更新dist[v5]=2，path[5]=9；v2结束，更新set[2]=1。以v3顶点向下遍历，dist(v3,v2)=2，即dist(v0,v3,v2)=8&gt;dist(v0,v1,v2)=5，不更新dist[2]；dist(v3,v5)=5，即dist(v0,v3,v5)=11&gt;dist(v0,v1,v2,v5)=9,不更新dist[5]；v3结束，更新set[3]=1。此时数据：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dist[]</strong></td>
<td><strong>0</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>11</strong></td>
<td><strong>9</strong></td>
<td><strong>∞</strong></td>
</tr>
<tr>
<td><strong>Path[]</strong></td>
<td><strong>-1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>-1</strong></td>
</tr>
<tr>
<td><strong>Set[]</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody></table>
<p><strong>按照上述遍历整个图。</strong></p>
<p><strong>示例代码：dijkstra1.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dijkstra算法（最短路径：带权重的路径）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">7</span>;<span class="comment">//图的顶点个数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有向图矩阵 </span></span><br><span class="line"><span class="comment">结点其他六个点的路径长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> MGraph[<span class="number">7</span>][<span class="number">7</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">4.0</span>,<span class="number">6.0</span>,<span class="number">6.0</span>,INF,INF,INF&#125;,</span><br><span class="line">	&#123;INF,<span class="number">0</span>,<span class="number">1.0</span>,INF,<span class="number">7.0</span>,INF,INF&#125;,</span><br><span class="line">	&#123;INF,INF,<span class="number">0</span>,INF,<span class="number">6.0</span>,<span class="number">4.0</span>,INF&#125;,</span><br><span class="line">	&#123;INF,INF,<span class="number">2.0</span>,<span class="number">0</span>,INF,<span class="number">5.0</span>,INF&#125;,</span><br><span class="line">	&#123;INF,INF,INF,INF,<span class="number">0</span>,INF,<span class="number">6.0</span>&#125;,</span><br><span class="line">	&#123;INF,INF,INF,INF,<span class="number">1.0</span>,<span class="number">0</span>,<span class="number">8.0</span>&#125;,</span><br><span class="line">	&#123;INF,INF,INF,INF,INF,INF,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> dist[<span class="number">7</span>];<span class="comment">//保存最短路径的长度 </span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">7</span>];<span class="comment">//保存最短路径 </span></span><br><span class="line"><span class="comment">//v0：起始点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">7</span>];<span class="comment">//标记顶点是否被遍历过，0:代表未遍历，1：代表已遍历</span></span><br><span class="line">	<span class="keyword">int</span> min,v;<span class="comment">//v:点到下一层遍历的路径最短的点 min:到最短点的路径长 </span></span><br><span class="line">	<span class="comment">//初始化dist[],path[],set[] </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//将起始点到各个点的起始状态赋值给dist[] </span></span><br><span class="line">		dist[i]=MGraph[v0][i];</span><br><span class="line">		<span class="comment">//set[]一开始都设置为0 </span></span><br><span class="line">		<span class="built_in">set</span>[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//如果起始点到某个点的起始距离不为无穷大，则说明 这个点为起始点的下一层点 </span></span><br><span class="line">		<span class="keyword">if</span>(MGraph[v0][i]&lt;INF)</span><br><span class="line">			<span class="comment">//即此时v0下一层所有点的上层点都是v0 </span></span><br><span class="line">			path[i]=v0;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">//path[i]=-1说明该点暂时还没有上一层的点 </span></span><br><span class="line">			path[i]=<span class="number">-1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//初始化v0初始状态 </span></span><br><span class="line">	<span class="built_in">set</span>[v0]=<span class="number">1</span>;path[v0]=<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//依次遍历下一层的点,v0起始点已经遍历过了，不需要再次遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		min=INF;<span class="comment">//初始化最短路径长度</span></span><br><span class="line">		<span class="comment">//遍历vi点的下一层到达的点</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="comment">//如果dist[j]不是无穷大，说明该点是vi的下一层点</span></span><br><span class="line">				<span class="comment">//如果set[j]==0说明该点没有遍历过，</span></span><br><span class="line">				<span class="comment">//满足这个两个条件，说明该点需要遍历 </span></span><br><span class="line">				<span class="comment">//遍历满足这个两个条件的所有点，并挑选出路径最短的点 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">set</span>[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;min)&#123;</span><br><span class="line">					v=j;min=dist[j];</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//得出遍历的点到下一层最短的点是v,距离是dist[v]</span></span><br><span class="line">			<span class="built_in">set</span>[v]=<span class="number">1</span>; </span><br><span class="line">			<span class="comment">//比较距离 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="comment">//dist[j]表示v0点到vj点当前最短距离</span></span><br><span class="line">				<span class="comment">//dist[v]+MGraph[v][j]表示上一个并入的顶点距离（v0到上一个顶点距离）到下一层顶点的距离 </span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">set</span>[j]==<span class="number">0</span>&amp;&amp;dist[v]+MGraph[v][j]&lt;dist[j])&#123;</span><br><span class="line">					dist[j]=dist[v]+MGraph[v][j];</span><br><span class="line">					path[j]=v; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; 	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入起始点：&quot;</span>);	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入终点：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m); </span><br><span class="line">	dijkstra(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;从v%d到v%d的最短距离为：%.2f&quot;</span>,n,m,dist[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-Floyd</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-Floyd/</url>
    <content><![CDATA[<h4 id="floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p><strong>Flody算法：寻找给的定权图中节点间的最短路径。（插点法）</strong></p>
<p><strong>核心依据：以下图为例</strong></p>
<span id="more"></span>

<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-Floyd/7.1.png" alt="7.1"></p>
<p>①如果某个节点位于从起点到终点的最短路径上：</p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-Floyd/7.2.png" alt="7.2"></p>
<p>②如果某个节点不在从起点到终点的最短路径上：</p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-Floyd/7.3.png" alt="7.3"></p>
<p>由①转化为代码就是distance[i][k]+distance[k][j]&lt;distance[i][j]，即起始点到中间节点距离+中间节点到终点距离是否小于起始点到终点的距离（如果不能直接到达，初始化为无穷大），如果小于就更新起始点到终点的距离，即distance[i][j]=distance[i][k]+distance[k][j]，同时更新路径path[i][j]=path[i][k]。</p>
<p>示例分析：构建两个二维数组distance[5][5]，path[5][5]，distance[5][5]代表两个节点间的最短距离，path[5][5]代表最短路径。如下表所示：</p>
<table>
<thead>
<tr>
<th>D（节点）</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>-3</td>
<td>2</td>
<td>-4</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>0</td>
<td>-4</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>2</td>
<td>7</td>
<td>4</td>
<td>0</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>-1</td>
<td>-5</td>
<td>0</td>
<td>-2</td>
</tr>
<tr>
<td>4</td>
<td>8</td>
<td>5</td>
<td>1</td>
<td>6</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>p（节点）</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>-1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>-1</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>-1</td>
</tr>
</tbody></table>
<p>示例代码：<strong>flody.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*弗洛伊德算法（flody），求有向图最短路径问题*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTICES 5 <span class="comment">//顶点个数 </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="comment">//结点间的最短距离</span></span><br><span class="line">	<span class="keyword">int</span> distance[VERTICES][VERTICES]= &#123;</span><br><span class="line">		&#123;F,<span class="number">3</span>,<span class="number">8</span>,F,<span class="number">-4</span>&#125;,</span><br><span class="line">		&#123;F,F,F,<span class="number">1</span>,<span class="number">7</span>&#125;,</span><br><span class="line">		&#123;F,<span class="number">4</span>,F,F,F&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>,F,<span class="number">-5</span>,F,F&#125;,</span><br><span class="line">		&#123;F,F,F,<span class="number">6</span>,F&#125;</span><br><span class="line">	&#125;;<span class="comment">//0代表到自身</span></span><br><span class="line">	<span class="comment">//结点间最短距离的路径</span></span><br><span class="line">	<span class="keyword">int</span> path[VERTICES][VERTICES]= &#123;</span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;</span><br><span class="line">	&#125;; <span class="comment">//-1代表没有上一个节点</span></span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;VERTICES; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;VERTICES; i++)</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;VERTICES; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(distance[i][k]+distance[k][j]&lt;distance[i][j]) &#123;</span><br><span class="line">					distance[i][j]=distance[i][k]+distance[k][j];</span><br><span class="line">					path[i][j]=path[i][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> s, en;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;en);</span><br><span class="line">	<span class="keyword">int</span> f=s;</span><br><span class="line">	<span class="keyword">while</span> (f!=en) &#123;</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,f);</span><br><span class="line">		 f=path[f][en];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,en);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,distance[s][en]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-KMP</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-KMP/</url>
    <content><![CDATA[<h4 id="kmp字符串匹配算法"><a href="#KMP-字符串匹配算法" class="headerlink" title="KMP(字符串匹配算法)"></a>KMP(字符串匹配算法)</h4><p><strong>理解：KMP算法是优化的字符串匹配算法，核心是通过利用匹配失败后的信息，尽量减少要查询的字符串与模板字符串的比较。</strong></p>
<p><strong>重点：KMP算法的核心在于利用匹配失败后的信息，那么如何利用这些信息时重点。构造要查询字符串的前缀表，记录要查询字符串的前后重复的字符。</strong></p>
<span id="more"></span>

<p><strong>如图所示：</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-KMP/12.jpg" alt="12"></p>
<p><strong>寻找字符串中前后缀相同的数量。填入前缀表，最后一个不要，整体右移一位。即：</strong></p>
<table>
<thead>
<tr>
<th><strong>下标</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>值</strong></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>c</strong></td>
</tr>
<tr>
<td><strong>前缀表</strong></td>
<td><strong>-1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
</tr>
</tbody></table>
<p><strong>这样做的理由是，如果字符串比较失败后，可以根据前后缀一样的特点，直接跳过后面与前面一样的部分，不在比较。如 ababc 要与baabababc比较，第一次比较如表：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>c</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>下标</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>值</strong></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>c</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>前缀表</strong></td>
<td><strong>-1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>第一次比较前四个都能匹配最后一个c不能匹配，c对应的前缀表值为2，就让a[2]移动到原先c的位置，因为前缀表的2，表示abab的前后2个字符串一样，这样就不必重复比较，所以第二次比较如下表：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>c</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>下标</strong></td>
<td></td>
<td></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>值</strong></td>
<td></td>
<td></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>a</strong></td>
<td><strong>b</strong></td>
<td><strong>c</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>前缀表</strong></td>
<td></td>
<td></td>
<td><strong>-1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>KMP算法就是依照这样的方法提高字符串的匹配效率。</strong></p>
<p><strong>示例：a[]=”BABCABAA”,匹配文本 text[]=”ABABCEABABCABAAADDB”</strong></p>
<p><strong>示例代码：kmp.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//ҪƥŤז·û´®µć°׺±�</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prefix_table</span><span class="params">(<span class="keyword">char</span> pattern[],<span class="keyword">int</span> prefix[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	prefix[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pattern[i] == pattern[len])&#123;</span><br><span class="line">			len ++;</span><br><span class="line">			prefix[i]=len;</span><br><span class="line">			i++; </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">				len = prefix[len<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				prefix[i]=<span class="number">0</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_prefix_table</span><span class="params">(<span class="keyword">int</span> prefix[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		prefix[i]=prefix[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	prefix[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_search</span><span class="params">(<span class="keyword">char</span> text[],<span class="keyword">char</span> pattern[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">	<span class="keyword">int</span> m = <span class="built_in">strlen</span>(text);</span><br><span class="line">	<span class="keyword">int</span>* prefix=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">	prefix_table(pattern,prefix,n);</span><br><span class="line">	move_prefix_table(prefix,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==n<span class="number">-1</span>&amp;&amp;text[i]==pattern[j])&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Found pattern at %d\n&quot;</span>,i-j+<span class="number">1</span>);</span><br><span class="line">			j=prefix[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(text[i]==pattern[j])&#123;</span><br><span class="line">			i++;j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j=prefix[j];</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">-1</span>)&#123;</span><br><span class="line">				i++;j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> pattern[]=<span class="string">&quot;BABCABAA&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> text[]=<span class="string">&quot;ABABCEABABCABAAADDB&quot;</span>;</span><br><span class="line">	kmp_search(text,pattern);</span><br><span class="line">	<span class="comment">/*int prefix[9];</span></span><br><span class="line"><span class="comment">	int n=9;</span></span><br><span class="line"><span class="comment">	prefiex_table(pattern,prefix,n);</span></span><br><span class="line"><span class="comment">	move_prefix_table(prefix,9);</span></span><br><span class="line"><span class="comment">	for(int i = 0; i &lt; n; i ++)&#123;</span></span><br><span class="line"><span class="comment">		printf(&quot;%d &quot;,prefix[i]);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>暴力字符串匹配示例代码：kmp0.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int t;</span><br><span class="line">bool check(char a[],char b[],int s1,int n,int s2,int m)&#123;</span><br><span class="line">	int l&#x3D;s1;</span><br><span class="line">	t&#x3D;0;</span><br><span class="line">	for(int i&#x3D;s2;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		if(a[l]&#x3D;&#x3D;b[i])</span><br><span class="line">			t++;l++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(t&#x3D;&#x3D;l) return true;</span><br><span class="line">	if(l&#x3D;&#x3D;m) return false;</span><br><span class="line">	check(a,b,s1+1,n,s2,m);	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	char a[n];</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;n;i++)</span><br><span class="line">		a[i]&#x3D;getchar();</span><br><span class="line">		</span><br><span class="line">	int m;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">	char b[m];</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;m;i++)</span><br><span class="line">		b[m]&#x3D;getchar();</span><br><span class="line">		</span><br><span class="line">	if(check(a,b,0,n,0,m))</span><br><span class="line">		printf(&quot;true&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;false&quot;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二分查找</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>前提条件：表中的数据是顺序存储结构</strong></p>
<p><strong>查找过程：首先，假设表中的数据是按升序排列，将表中的中间位置记录的数据与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录的数据将表分成前后两个表，如果中间位置的数据大于要查找的关键字就查找前一个表，如果中间位置的数据大于要查找的关键字就查找后一个表；重复以上过程，直到查到满足条件的记录，就查找成功，否则要查找的数据不存在数据表中，查找不成功。</strong></p>
<span id="more"></span>

<p><strong>示例：在数组中查找值，返回下标</strong></p>
<p><strong>示例代码：binary_search.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *二分查找</span></span><br><span class="line"><span class="comment"> *要求数列是顺序存储结构 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="comment">//数据 </span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">34</span>,<span class="number">51</span>,<span class="number">67</span>&#125;;</span><br><span class="line">	<span class="comment">//要查找的数据 </span></span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">51</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="comment">//m:数组的中间位置 </span></span><br><span class="line">	<span class="keyword">int</span> m =s+ (e-s)/<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//如果开始地址大于尾地址，数组查找完了 并没有找到值 </span></span><br><span class="line">	<span class="keyword">if</span>(s &gt; e)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果中间位置的值等于要查询的值，就放回要查找的值在数组中的下标 </span></span><br><span class="line">		<span class="keyword">if</span>(a[m] == x) </span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[m] &gt; x)<span class="comment">//如果中间位置的值大于要查询的值，就一中间位置划分数组，查询前一部分 </span></span><br><span class="line">			<span class="keyword">return</span> binary_search(s,m<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//如果中间位置的值小于要查询的值，就一中间位置划分数组，查询后一部分 </span></span><br><span class="line">		  <span class="keyword">return</span> binary_search(m+<span class="number">1</span>,e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用二分查询 </span></span><br><span class="line">	<span class="keyword">int</span> m = binary_search(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span>(m!=<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查找成功，查找数据的下标为%d&quot;</span>,m);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查找失败，查找数据不存在&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-全排列</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p><strong>概念</strong>：<strong>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</strong></p>
<span id="more"></span>

<p><strong>示例：对a[1,2,3,4,5]进行全排列</strong></p>
<p><strong>分析过程：全排列：如 对1，2，3，4，5全排列，先取出其中任意一个数如1，然后对其他的数全排列，再取出除1之外的任意一个数，然后对其他的数全排列，依次这样下去，直到五个数取完为止 。</strong></p>
<p><strong>示例代码：premutation.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">全排列：如 对1，2，3，4，5全排列</span></span><br><span class="line"><span class="comment">先取出其中任意一个数如1，然后对其他的数全排列</span></span><br><span class="line"><span class="comment">再取出除1之外的任意一个数，然后对其他的数全排列</span></span><br><span class="line"><span class="comment">依次这样下去，直到五个数取完为止 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//交换值 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp= a[p];</span><br><span class="line">	a[p]=a[q];</span><br><span class="line">	a[q]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全排列 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="comment">//直到取到结束下标为止 </span></span><br><span class="line">	<span class="keyword">if</span>(q==p) &#123;</span><br><span class="line">		print(a,q+<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//重复的数不必再排列 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=p; i&lt;=q; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(j = p; j &lt; i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j] == a[i]) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">				swap(a,p,i);<span class="comment">//交换数据 </span></span><br><span class="line">				perm(a,p+<span class="number">1</span>,q);<span class="comment">//对剩余的数进行全排列 </span></span><br><span class="line">				swap(a,p,i);<span class="comment">//交换回来 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span>(q==p) &#123;</span><br><span class="line">		print(a,q+<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=p; i&lt;=q; i++) &#123;</span><br><span class="line">			swap(a,p,i);</span><br><span class="line">			perm(a,p+<span class="number">1</span>,q);</span><br><span class="line">			swap(a,p,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入数据个数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a[n]; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n请输入数据：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	perm(a,<span class="number">0</span>,n<span class="number">-1</span>);<span class="built_in">printf</span>(<span class="string">&quot;=========================&quot;</span>) ;</span><br><span class="line">	</span><br><span class="line">	perm2(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：对b[1,1,2,3,4]进行全排列</strong></p>
<p><strong>分析过程：重复数据，如果有重复数据则不必再全排列</strong></p>
<p><strong>示例代码：premutation.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">全排列：如 对1，2，3，4，5全排列</span><br><span class="line">先取出其中任意一个数如1，然后对其他的数全排列</span><br><span class="line">再取出除1之外的任意一个数，然后对其他的数全排列</span><br><span class="line">依次这样下去，直到五个数取完为止 </span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">&#x2F;&#x2F;交换值 </span><br><span class="line">void swap(int a[],int p,int q) &#123;</span><br><span class="line">	int temp&#x3D; a[p];</span><br><span class="line">	a[p]&#x3D;a[q];</span><br><span class="line">	a[q]&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出 </span><br><span class="line">void print(int a[],int n) &#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">		printf(&quot;%d&quot;,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;全排列 </span><br><span class="line">void perm(int a[],int p,int q) &#123;</span><br><span class="line">	int j;</span><br><span class="line">	&#x2F;&#x2F;直到取到结束下标为止 </span><br><span class="line">	if(q&#x3D;&#x3D;p) &#123;</span><br><span class="line">		print(a,q+1);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F;重复的数不必再排列 </span><br><span class="line">		for(int i&#x3D;p; i&lt;&#x3D;q; i++) &#123;</span><br><span class="line">			for(j &#x3D; p; j &lt; i; j++) &#123;</span><br><span class="line">				if(a[j] &#x3D;&#x3D; a[i]) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">				swap(a,p,i);&#x2F;&#x2F;交换数据 </span><br><span class="line">				perm(a,p+1,q);&#x2F;&#x2F;对剩余的数进行全排列 </span><br><span class="line">				swap(a,p,i);&#x2F;&#x2F;交换回来 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void perm2(int a[],int p,int q) &#123;</span><br><span class="line">	int j;</span><br><span class="line">	if(q&#x3D;&#x3D;p) &#123;</span><br><span class="line">		print(a,q+1);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for(int i&#x3D;p; i&lt;&#x3D;q; i++) &#123;</span><br><span class="line">			swap(a,p,i);</span><br><span class="line">			perm(a,p+1,q);</span><br><span class="line">			swap(a,p,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	printf(&quot;请输入数据个数：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int a[n]; </span><br><span class="line">	printf(&quot;\n请输入数据：&quot;);</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	perm(a,0,n-1);printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) ;</span><br><span class="line">	</span><br><span class="line">	perm2(a,0,n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>概念：求解决策过程中最优化的数学方法。把多个阶段过程转换为一系列单阶段问题，利用各个阶段间的关系，逐个求解。</strong></p>
<span id="more"></span>

<p><strong>个人理解：递归的逆推过程</strong></p>
<p><strong>示例：有一堆数，a[1,2,4,1,7,8,3]，选择不相邻的几个数，相加出最大的数。定义最优解为d[i],即到i之前的最佳方案。每个数都有两种选择-选和不选。则d[i]=d<a href="%E4%B8%8D%E9%80%89%E8%BF%99%E4%B8%AA%E6%95%B0">i-1</a>|d[i]=d[i-2]+a<a href="%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E6%95%B0">i</a>。选择i最佳方案的值就是i-2之前最佳的方案的值加第i个数值。不选i,最佳方案的值就是i-1之间最佳方案的值。</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.1.png" alt="6.1"></p>
<p><strong>示例代码：dp.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dynamic program 动态规划</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> m;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A,B;<span class="comment">//A :选择当前数后的结果，B:不选择当前数后的结果 </span></span><br><span class="line">	<span class="keyword">int</span> b[len]=&#123;<span class="number">0</span>&#125;;<span class="comment">//b[len]表示选择的数，数值加在一起的值 </span></span><br><span class="line">	b[<span class="number">0</span>]=a[<span class="number">0</span>];	<span class="comment">//初始化当数只有一个时，最终结果就是b[0] </span></span><br><span class="line">	b[<span class="number">1</span>] = max(a[<span class="number">0</span>],a[<span class="number">1</span>]);<span class="comment">//当前数值就是 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">	 	A = b[i<span class="number">-2</span>] + a[i];<span class="comment">//选择 a[i] </span></span><br><span class="line">	 	B = b[i<span class="number">-1</span>];<span class="comment">//不选择 a[i]</span></span><br><span class="line">	 	b[i]=max(A,B);<span class="comment">//比较选择和不选择a[i]后那个结果更大些 </span></span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span> b[len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 由这些数中挑选相加成最大的数，相邻两个数不可同时选择 </span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="comment">//数组长度 </span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp(a,len));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>示例：区间问题，有1-8份工作，占用时间不同，价值不同，要求在时间不冲突的情况下，选择工作，挣最多的钱。</strong></p>
<p><strong>分析过程：</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.1.png" alt="6.1"></p>
<p><strong>示例代码：dp1.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;dynamic program 动态规划</span><br><span class="line">&#x2F;&#x2F;选择不冲突的任务，使得到的钱最多</span><br><span class="line">&#x2F;*测试数据</span><br><span class="line">8</span><br><span class="line">5 1 4</span><br><span class="line">1 3 5</span><br><span class="line">8 0 6</span><br><span class="line">4 4 7</span><br><span class="line">6 3 8</span><br><span class="line">3 5 9</span><br><span class="line">2 6 10</span><br><span class="line">4 8 11</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int value[8]; &#x2F;&#x2F;价值</span><br><span class="line">int end_time[8];&#x2F;&#x2F;任务开始时间</span><br><span class="line">int start_time[8];&#x2F;&#x2F;任务结束时间</span><br><span class="line">int prev[8];&#x2F;&#x2F;如果确定做这一任务，那么下一个可以做的任务是？下一个任务的下标 </span><br><span class="line">int n&#x3D;8;&#x2F;&#x2F;任务数量</span><br><span class="line">int m&#x3D;0;</span><br><span class="line">int max(int n,int m) &#123;</span><br><span class="line">	if(n&gt;m)	return n;</span><br><span class="line">	else return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int OPT(int i);</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;value[i]);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;start_time[i]);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;end_time[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;初始化数据</span><br><span class="line">	for(int i&#x3D;0; i&lt;8; i++) &#123;</span><br><span class="line">		prev[i]&#x3D;-1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1; i&lt;8; i++) &#123;</span><br><span class="line">		for(int j&#x3D;0; j&lt;i; j++) &#123;</span><br><span class="line">			if(start_time[i]&gt;&#x3D;end_time[j])</span><br><span class="line">				prev[i]&#x3D;max(prev[i],j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0; i&lt;8; i++) &#123;</span><br><span class="line">		printf(&quot;%d &quot;,prev[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n%d &quot;,OPT(8));</span><br><span class="line">&#125;</span><br><span class="line">int OPT(int i) &#123;</span><br><span class="line">	if(i &#x3D;&#x3D; -1) return 0;</span><br><span class="line">	return max(OPT(i-1), value[i]+OPT(prev[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：背包容量为s,有一堆物品大小不同，随意挑选物品，判断背包是否能正好背装满。</strong></p>
<p><strong>分析过程：</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.2.png" alt="6.2"></p>
<p><strong>示例代码：dp2.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">&#x2F;&#x2F;背包容量为s,有一堆物品大小不同，随意挑选物品，判断背包是否能正好背装满。 </span><br><span class="line">&#x2F;&#x2F;递归</span><br><span class="line">bool subset(int arr[],int i,int s) &#123;</span><br><span class="line">	if(s &#x3D;&#x3D; 0)  return true;</span><br><span class="line">	else if(i &#x3D;&#x3D; 0) return arr[0] &#x3D;&#x3D; s;</span><br><span class="line">	else if(arr[i]&gt;s) return subset(arr,i-1,s);</span><br><span class="line">	else &#123;</span><br><span class="line">		int A &#x3D; subset(arr,i-1,s-arr[i]);</span><br><span class="line">		int B &#x3D; subset(arr,i-1,s);</span><br><span class="line">		return A or B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int sub[6][100];</span><br><span class="line">bool dp_subset(int goods[],int s,int length) &#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;length; i++) &#123; &#x2F;&#x2F;初始化</span><br><span class="line">		for(int j&#x3D;0; j&lt;&#x3D;s; j++) &#123;</span><br><span class="line">			if(i&#x3D;&#x3D;0) sub[0][j]&#x3D;0;</span><br><span class="line">			if(j&#x3D;&#x3D;0) sub[i][0]&#x3D;1;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sub[0][goods[0]]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1; i&lt;length; i++) &#123; &#x2F;&#x2F;初始化</span><br><span class="line">		for(int j&#x3D;1; j&lt;&#x3D;s; j++) &#123;</span><br><span class="line"></span><br><span class="line">			if(goods[i]&gt;s)</span><br><span class="line">				sub[i][j]&#x3D;sub[i-1][j] ;</span><br><span class="line">			else &#123;</span><br><span class="line">				int A &#x3D; sub[i-1][j-goods[i]];</span><br><span class="line">				int B &#x3D; sub[i-1][j];</span><br><span class="line">				sub[i][j] &#x3D; A or B; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sub[length-1][s];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	int s;&#x2F;&#x2F;背包容量 </span><br><span class="line">	printf(&quot;请输入背包容量：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;s); </span><br><span class="line">	</span><br><span class="line">	int length;&#x2F;&#x2F;物品的数量 </span><br><span class="line">	printf(&quot;\n请输入物品的数量：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;length);</span><br><span class="line">	</span><br><span class="line">	int goods[length]; &#x2F;&#x2F;物品重量&#x3D; &#123;3 34 4 12 5 2&#125;</span><br><span class="line">	printf(&quot;\n请输入每个物品的重量：&quot;);</span><br><span class="line">	for(int i&#x3D;0;i&lt;length;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;goods[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	if(dp_subset(goods,s,length))</span><br><span class="line">		printf(&quot;\ntrue&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;\nfalse&quot;);</span><br><span class="line">	</span><br><span class="line">&#x2F;*	printf(&quot;%d\n&quot;,dp_subset(goods,s,length));</span><br><span class="line">	for(int i&#x3D;0; i&lt;length; i++) &#123; &#x2F;&#x2F;初始化</span><br><span class="line">		for(int j&#x3D;0; j&lt;&#x3D;s; j++) &#123;</span><br><span class="line">			printf(&quot;%d &quot;,sub[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-哈夫曼树</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p><strong>概念：哈夫曼树又称最优二叉树，哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</strong></p>
<span id="more"></span>

<p><strong>哈夫曼树如图：</strong></p>
<p> <img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/14.1.png">      </p>
<p><strong>带权路径长度WPL=  ，w指权值，l指结点高度</strong></p>
<p><strong>示例：有19米长的木板，切割成8m,3m,8m三份，切割的木板多长就需要花费多少金币，求花费最少为多少金币？</strong></p>
<p><strong>示例代码：huffman.cpp</strong></p>
<p><strong>哈夫曼编码：能够使用尽可能少的编码总位数表示字符串，且能够保证没有一个字符的编码是另外一个字符编码的前缀，不会出现二义性。</strong></p>
<p><strong>示例：比如 a b c d e 出现的频率分别是5 4 3 2 1 求a b c d e 的哈夫曼编码。</strong></p>
<p><strong>分析过程：</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/14.2.png"></p>
<p><strong>示例代码：huffman3.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">//带权值的叶子节点数或者是需要编码的字符数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2*N-1<span class="comment">//n个叶子节点构造的哈夫曼树有2n-1个结点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="comment">//静态三叉链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="comment">//TElemType data;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> weight;<span class="comment">//权值只能是正数</span></span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">	<span class="keyword">int</span> lchild;</span><br><span class="line">	<span class="keyword">int</span> rchild;</span><br><span class="line">&#125;HTNode;<span class="comment">//, *HuffmanTree;</span></span><br><span class="line"><span class="keyword">typedef</span> HTNode HuffmanTree[M+<span class="number">1</span>];<span class="comment">//0号单元不使用</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * HuffmanCode[N+<span class="number">1</span>];<span class="comment">//存储每个字符的哈夫曼编码表，是一个字符指针数组，每个数组元素是指向字符指针的指针</span></span><br><span class="line"><span class="comment">//构造哈夫曼树</span></span><br><span class="line"><span class="comment">//在HT[1...k]里选择parent为0的且权值最小的2结点，其序号分别为s1,s2，parent不为0说明该结点已经参与构造了，故不许再考虑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="comment">//假设s1对应的权值总是&lt;=s2对应的权值</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = MAX, tmpi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!HT[i].parent)&#123;<span class="comment">//parent必须为0</span></span><br><span class="line">			<span class="keyword">if</span>(tmp &gt; HT[i].weight)&#123;</span><br><span class="line">				tmp = HT[i].weight;<span class="comment">//tmp最后为最小的weight</span></span><br><span class="line">				tmpi = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s1 = tmpi;</span><br><span class="line">	</span><br><span class="line">	tmp = MAX;</span><br><span class="line">	tmpi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((!HT[i].parent) &amp;&amp; i!=s1)&#123;<span class="comment">//parent为0</span></span><br><span class="line">			<span class="keyword">if</span>(tmp &gt; HT[i].weight)&#123;</span><br><span class="line">				tmp = HT[i].weight;</span><br><span class="line">				tmpi = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s2 = tmpi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHuffmanTree</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> *w, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//对树赋初值</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//HT前n个分量存储叶子节点，他们均带有权值</span></span><br><span class="line">		HT[i].weight = w[i];</span><br><span class="line">		HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">		HT[i].parent = <span class="number">0</span>;</span><br><span class="line">		HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(; i &lt;=M; i++)&#123;<span class="comment">//HT后m-n个分量存储中间结点，最后一个分量显然是整棵树的根节点</span></span><br><span class="line">		HT[i].weight = <span class="number">0</span>;</span><br><span class="line">		HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">		HT[i].parent = <span class="number">0</span>;</span><br><span class="line">		HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始构建哈夫曼树，即创建HT的后m-n个结点的过程，直至创建出根节点。用哈夫曼算法</span></span><br><span class="line">	<span class="keyword">for</span>(i = n+<span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s1, s2;</span><br><span class="line">		select(HT, i<span class="number">-1</span>, s1, s2);<span class="comment">//在HT[1...i-1]里选择parent为0的且权值最小的2结点，其序号分别为s1,s2，parent不为0说明该结点已经参与构造了，故不许再考虑</span></span><br><span class="line">		HT[s1].parent = i;</span><br><span class="line">		HT[s2].parent = i;</span><br><span class="line">		HT[i].lchild = s1;</span><br><span class="line">		HT[i].rchild = s2;</span><br><span class="line">		HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印哈夫曼满树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHuffmanTree</span><span class="params">(HuffmanTree HT, <span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data, weight, parent, lchild, rchild\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt; N)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  -, %5d, %5d, %5d, %5d\n&quot;</span>, HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  %c, %5d, %5d, %5d, %5d\n&quot;</span>, ch[i], HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为每个字符求解哈夫曼编码，从叶子到根逆向求解每个字符的哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encodingHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC)</span></span>&#123;</span><br><span class="line">	<span class="comment">//char *tmp = (char *)malloc(n * sizeof(char));//将每一个字符对应的编码放在临时工作空间tmp里，每个字符的编码长度不会超过n</span></span><br><span class="line">	<span class="keyword">char</span> tmp[N];</span><br><span class="line">	tmp[N<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//编码的结束符</span></span><br><span class="line">	<span class="keyword">int</span> start, c, f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;<span class="comment">//对于第i个待编码字符即第i个带权值的叶子节点</span></span><br><span class="line">		start = N<span class="number">-1</span>;<span class="comment">//编码生成以后，start将指向编码的起始位置</span></span><br><span class="line">		c = i;</span><br><span class="line">		f = HT[i].parent;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span>(f)&#123;<span class="comment">//f!=0,即f不是根节点的父节点</span></span><br><span class="line">			<span class="keyword">if</span>(HT[f].lchild == c)&#123;</span><br><span class="line">				tmp[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">//HT[f].rchild == c,注意:由于哈夫曼树中只存在叶子节点和度为2的节点，所以除开叶子节点，节点一定有左右2个分支</span></span><br><span class="line">				tmp[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			c = f;</span><br><span class="line">			f = HT[f].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		HC[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((N-start)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//每次tmp的后n-start个位置有编码存在</span></span><br><span class="line">		<span class="built_in">strcpy</span>(HC[i], &amp;tmp[start]);<span class="comment">//将tmp的后n-start个元素分给H[i]指向的的字符串</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印哈夫曼编码表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHuffmanCoding</span><span class="params">(HuffmanCode HC, <span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c:%s\n&quot;</span>, ch[i], HC[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解码过程：从哈夫曼树的根节点出发，按字符&#x27;0&#x27;或&#x27;1&#x27;确定找其左孩子或右孩子，直至找到叶子节点即可，便求得该字串相应的字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decodingHuffmanCode</span><span class="params">(HuffmanTree HT, <span class="keyword">char</span> *ch, <span class="keyword">char</span> testDecodingStr[], <span class="keyword">int</span> len, <span class="keyword">char</span> *result)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = M;<span class="comment">//HT的最后一个节点是根节点，前n个节点是叶子节点</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//指示测试串中的第i个字符</span></span><br><span class="line">	<span class="comment">//char result[30];//存储解码以后的字符串</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//指示结果串中的第j个字符</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(testDecodingStr[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			p = HT[p].lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(testDecodingStr[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			p = HT[p].rchild;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(p &lt;= N)&#123;<span class="comment">//p&lt;=N则表明p为叶子节点,因为在构造哈夫曼树HT时，HT的m个节点中前n个节点为叶子节点</span></span><br><span class="line">			result[j] = ch[p];</span><br><span class="line">			j++;</span><br><span class="line">			p = M;<span class="comment">//p重新指向根节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	result[j] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//结果串的结束符	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	HuffmanTree HT;</span><br><span class="line">	</span><br><span class="line">	TElemType ch[N+<span class="number">1</span>];<span class="comment">//0号单元不使用，存储n个等待编码的字符</span></span><br><span class="line">	<span class="keyword">int</span> w[N+<span class="number">1</span>];<span class="comment">//0号单元不使用，存储n个字符对应的权值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个字符以及该字符对应的权值(如:a,20):\n&quot;</span>, N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c,%d&quot;</span>, &amp;ch[i], &amp;w[i]);</span><br><span class="line">		getchar();<span class="comment">//吃掉换行符</span></span><br><span class="line">	&#125;<span class="comment">//即w里第i个权值对应的是ch里第i个字符元素</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	createHuffmanTree(HT, w , N);<span class="comment">//构建哈夫曼树</span></span><br><span class="line">	printHuffmanTree(HT, ch);</span><br><span class="line">	</span><br><span class="line">	HuffmanCode HC;<span class="comment">//HC有n个元素，每个元素是一个指向字符串的指针，即每个元素是一个char *的变量</span></span><br><span class="line">	encodingHuffmanCode(HT, HC);<span class="comment">//为每个字符求解哈夫曼编码</span></span><br><span class="line">	printHuffmanCoding(HC, ch);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//解码测试用例：abaccda----01000101101110</span></span><br><span class="line">	<span class="keyword">char</span> * testDecodingStr = <span class="string">&quot;01000101101110&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> testDecodingStrLen = <span class="number">14</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;编码%s对应的字符串是：&quot;</span>, testDecodingStr);</span><br><span class="line">	<span class="keyword">char</span> result[<span class="number">30</span>];<span class="comment">//存储解码以后的字符串</span></span><br><span class="line">	decodingHuffmanCode(HT, ch, testDecodingStr, testDecodingStrLen, result);<span class="comment">//解码（译码），通过一段给定的编码翻译成对应的字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-哈希算法</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p><strong>概念：哈希算法是一种只能加密，不能解密的密码学算法，可以将任意长度的信息通过散列算法转换成一段固定长度的字符串，且若输入的消息不同，它们对应到不同字符串的机率很高</strong>。</p>
<span id="more"></span>

<p><strong>优秀的哈希算法有以下特点：</strong></p>
<p><strong>①正向快速，即要求在很快的时间内将明文通过散列算法计算出哈希值。</strong></p>
<p><strong>②逆向困难，即给定哈希值，在有限的时间内基本不可能逆推出明文。</strong></p>
<p><strong>③输入敏感，即输入信息稍微修改，产生的哈希值差别应该会很大。</strong></p>
<p><strong>④抗冲突性，不同的输入不能产生相同的输出，抗冲突性不是不会有冲突，只是找到有冲突的两个输入的代价非常大。</strong></p>
<p><strong>网址：<a href="http://www.fileformat.info/tool/hash.html">www.fileformat.info/tool/hash.html</a></strong></p>
<p><strong>示例：对任意字符串进行md5加密</strong></p>
<p><strong>示例代码：c2.dev(md5.h mad5.c main.c)</strong><br>    <strong>示例：哈希算法不仅仅可以用于加密，也可以用于检验信息是否是相同的，比如上传文件，对上传的文件生成哈希值，可以避免重复上传，因为上传的文件一样，他们生成的哈希值也是一样的，具体一点就是如果有人传送了一份文件给一个人，然后又有一个人传送了相同的文件给了另外一个人，那么这个社交软件在第二次传送文件的时候会对比两次传送的哈希值，发现是相同的，该软件就不会再次上传文件给服务器了。</strong></p>
<p><strong>示例代码：hash.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *POINTER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	UINT4 state[<span class="number">4</span>];</span><br><span class="line">	UINT4 count[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">&#125; MD5_CTX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MD5Init</span><span class="params">(MD5_CTX *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MD5Update</span><span class="params">(MD5_CTX *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MD5Final</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> [<span class="number">16</span>], MD5_CTX *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S11 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S12 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S13 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S14 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S21 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S22 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S23 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S24 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S31 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S32 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S33 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S34 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S41 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S42 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S43 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S44 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> PADDING[<span class="number">64</span>] = &#123;</span><br><span class="line">	<span class="number">0x80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(x, y, z) ((x) ^ (y) ^ (z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I(x, y, z) ((y) ^ ((x) | (~z)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROTATE_LEFT(x, n) (((x) <span class="meta-string">&lt;&lt; (n)) | ((x) &gt;</span>&gt; (32-(n))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF(a, b, c, d, x, s, ac) &#123;   (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac);   (a) = ROTATE_LEFT ((a), (s));   (a) += (b);   &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG(a, b, c, d, x, s, ac) &#123;   (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac);   (a) = ROTATE_LEFT ((a), (s));   (a) += (b);   &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HH(a, b, c, d, x, s, ac) &#123;   (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac);   (a) = ROTATE_LEFT ((a), (s));   (a) += (b);   &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> II(a, b, c, d, x, s, ac) &#123;   (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac);   (a) = ROTATE_LEFT ((a), (s));   (a) += (b); &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *output, UINT4 *input, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; len; i++, j += <span class="number">4</span>) &#123;</span><br><span class="line">		output[j] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(input[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">		output[j+<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((input[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		output[j+<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((input[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		output[j+<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((input[i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Decode</span><span class="params">(UINT4 *output, <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; len; i++, j += <span class="number">4</span>)</span><br><span class="line">		output[i] = ((UINT4)input[j]) | (((UINT4)input[j+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">		            (((UINT4)input[j+<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) | (((UINT4)input[j+<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MD5Transform</span> <span class="params">(UINT4 state[<span class="number">4</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> block[<span class="number">64</span>])</span> </span>&#123;</span><br><span class="line">	UINT4 a = state[<span class="number">0</span>], b = state[<span class="number">1</span>], c = state[<span class="number">2</span>], d = state[<span class="number">3</span>], x[<span class="number">16</span>];</span><br><span class="line">	Decode (x, block, <span class="number">64</span>);</span><br><span class="line">	FF (a, b, c, d, x[ <span class="number">0</span>], S11, <span class="number">0xd76aa478</span>);</span><br><span class="line">	FF (d, a, b, c, x[ <span class="number">1</span>], S12, <span class="number">0xe8c7b756</span>);</span><br><span class="line">	FF (c, d, a, b, x[ <span class="number">2</span>], S13, <span class="number">0x242070db</span>);</span><br><span class="line">	FF (b, c, d, a, x[ <span class="number">3</span>], S14, <span class="number">0xc1bdceee</span>);</span><br><span class="line">	FF (a, b, c, d, x[ <span class="number">4</span>], S11, <span class="number">0xf57c0faf</span>);</span><br><span class="line">	FF (d, a, b, c, x[ <span class="number">5</span>], S12, <span class="number">0x4787c62a</span>);</span><br><span class="line">	FF (c, d, a, b, x[ <span class="number">6</span>], S13, <span class="number">0xa8304613</span>);</span><br><span class="line">	FF (b, c, d, a, x[ <span class="number">7</span>], S14, <span class="number">0xfd469501</span>);</span><br><span class="line">	FF (a, b, c, d, x[ <span class="number">8</span>], S11, <span class="number">0x698098d8</span>);</span><br><span class="line">	FF (d, a, b, c, x[ <span class="number">9</span>], S12, <span class="number">0x8b44f7af</span>);</span><br><span class="line">	FF (c, d, a, b, x[<span class="number">10</span>], S13, <span class="number">0xffff5bb1</span>);</span><br><span class="line">	FF (b, c, d, a, x[<span class="number">11</span>], S14, <span class="number">0x895cd7be</span>);</span><br><span class="line">	FF (a, b, c, d, x[<span class="number">12</span>], S11, <span class="number">0x6b901122</span>);</span><br><span class="line">	FF (d, a, b, c, x[<span class="number">13</span>], S12, <span class="number">0xfd987193</span>);</span><br><span class="line">	FF (c, d, a, b, x[<span class="number">14</span>], S13, <span class="number">0xa679438e</span>);</span><br><span class="line">	FF (b, c, d, a, x[<span class="number">15</span>], S14, <span class="number">0x49b40821</span>);</span><br><span class="line">	GG (a, b, c, d, x[ <span class="number">1</span>], S21, <span class="number">0xf61e2562</span>);</span><br><span class="line">	GG (d, a, b, c, x[ <span class="number">6</span>], S22, <span class="number">0xc040b340</span>);</span><br><span class="line">	GG (c, d, a, b, x[<span class="number">11</span>], S23, <span class="number">0x265e5a51</span>);</span><br><span class="line">	GG (b, c, d, a, x[ <span class="number">0</span>], S24, <span class="number">0xe9b6c7aa</span>);</span><br><span class="line">	GG (a, b, c, d, x[ <span class="number">5</span>], S21, <span class="number">0xd62f105d</span>);</span><br><span class="line">	GG (d, a, b, c, x[<span class="number">10</span>], S22,   <span class="number">0x2441453</span>);</span><br><span class="line">	GG (c, d, a, b, x[<span class="number">15</span>], S23, <span class="number">0xd8a1e681</span>);</span><br><span class="line">	GG (b, c, d, a, x[ <span class="number">4</span>], S24, <span class="number">0xe7d3fbc8</span>);</span><br><span class="line">	GG (a, b, c, d, x[ <span class="number">9</span>], S21, <span class="number">0x21e1cde6</span>);</span><br><span class="line">	GG (d, a, b, c, x[<span class="number">14</span>], S22, <span class="number">0xc33707d6</span>);</span><br><span class="line">	GG (c, d, a, b, x[ <span class="number">3</span>], S23, <span class="number">0xf4d50d87</span>);</span><br><span class="line">	GG (b, c, d, a, x[ <span class="number">8</span>], S24, <span class="number">0x455a14ed</span>);</span><br><span class="line">	GG (a, b, c, d, x[<span class="number">13</span>], S21, <span class="number">0xa9e3e905</span>);</span><br><span class="line">	GG (d, a, b, c, x[ <span class="number">2</span>], S22, <span class="number">0xfcefa3f8</span>);</span><br><span class="line">	GG (c, d, a, b, x[ <span class="number">7</span>], S23, <span class="number">0x676f02d9</span>);</span><br><span class="line">	GG (b, c, d, a, x[<span class="number">12</span>], S24, <span class="number">0x8d2a4c8a</span>);</span><br><span class="line">	HH (a, b, c, d, x[ <span class="number">5</span>], S31, <span class="number">0xfffa3942</span>);</span><br><span class="line">	HH (d, a, b, c, x[ <span class="number">8</span>], S32, <span class="number">0x8771f681</span>);</span><br><span class="line">	HH (c, d, a, b, x[<span class="number">11</span>], S33, <span class="number">0x6d9d6122</span>);</span><br><span class="line">	HH (b, c, d, a, x[<span class="number">14</span>], S34, <span class="number">0xfde5380c</span>);</span><br><span class="line">	HH (a, b, c, d, x[ <span class="number">1</span>], S31, <span class="number">0xa4beea44</span>);</span><br><span class="line">	HH (d, a, b, c, x[ <span class="number">4</span>], S32, <span class="number">0x4bdecfa9</span>);</span><br><span class="line">	HH (c, d, a, b, x[ <span class="number">7</span>], S33, <span class="number">0xf6bb4b60</span>);</span><br><span class="line">	HH (b, c, d, a, x[<span class="number">10</span>], S34, <span class="number">0xbebfbc70</span>);</span><br><span class="line">	HH (a, b, c, d, x[<span class="number">13</span>], S31, <span class="number">0x289b7ec6</span>);</span><br><span class="line">	HH (d, a, b, c, x[ <span class="number">0</span>], S32, <span class="number">0xeaa127fa</span>);</span><br><span class="line">	HH (c, d, a, b, x[ <span class="number">3</span>], S33, <span class="number">0xd4ef3085</span>);</span><br><span class="line">	HH (b, c, d, a, x[ <span class="number">6</span>], S34,   <span class="number">0x4881d05</span>);</span><br><span class="line">	HH (a, b, c, d, x[ <span class="number">9</span>], S31, <span class="number">0xd9d4d039</span>);</span><br><span class="line">	HH (d, a, b, c, x[<span class="number">12</span>], S32, <span class="number">0xe6db99e5</span>);</span><br><span class="line">	HH (c, d, a, b, x[<span class="number">15</span>], S33, <span class="number">0x1fa27cf8</span>);</span><br><span class="line">	HH (b, c, d, a, x[ <span class="number">2</span>], S34, <span class="number">0xc4ac5665</span>);</span><br><span class="line">	II (a, b, c, d, x[ <span class="number">0</span>], S41, <span class="number">0xf4292244</span>);</span><br><span class="line">	II (d, a, b, c, x[ <span class="number">7</span>], S42, <span class="number">0x432aff97</span>);</span><br><span class="line">	II (c, d, a, b, x[<span class="number">14</span>], S43, <span class="number">0xab9423a7</span>);</span><br><span class="line">	II (b, c, d, a, x[ <span class="number">5</span>], S44, <span class="number">0xfc93a039</span>);</span><br><span class="line">	II (a, b, c, d, x[<span class="number">12</span>], S41, <span class="number">0x655b59c3</span>);</span><br><span class="line">	II (d, a, b, c, x[ <span class="number">3</span>], S42, <span class="number">0x8f0ccc92</span>);</span><br><span class="line">	II (c, d, a, b, x[<span class="number">10</span>], S43, <span class="number">0xffeff47d</span>);</span><br><span class="line">	II (b, c, d, a, x[ <span class="number">1</span>], S44, <span class="number">0x85845dd1</span>);</span><br><span class="line">	II (a, b, c, d, x[ <span class="number">8</span>], S41, <span class="number">0x6fa87e4f</span>);</span><br><span class="line">	II (d, a, b, c, x[<span class="number">15</span>], S42, <span class="number">0xfe2ce6e0</span>);</span><br><span class="line">	II (c, d, a, b, x[ <span class="number">6</span>], S43, <span class="number">0xa3014314</span>);</span><br><span class="line">	II (b, c, d, a, x[<span class="number">13</span>], S44, <span class="number">0x4e0811a1</span>);</span><br><span class="line">	II (a, b, c, d, x[ <span class="number">4</span>], S41, <span class="number">0xf7537e82</span>);</span><br><span class="line">	II (d, a, b, c, x[<span class="number">11</span>], S42, <span class="number">0xbd3af235</span>);</span><br><span class="line">	II (c, d, a, b, x[ <span class="number">2</span>], S43, <span class="number">0x2ad7d2bb</span>);</span><br><span class="line">	II (b, c, d, a, x[ <span class="number">9</span>], S44, <span class="number">0xeb86d391</span>);</span><br><span class="line">	state[<span class="number">0</span>] += a;</span><br><span class="line">	state[<span class="number">1</span>] += b;</span><br><span class="line">	state[<span class="number">2</span>] += c;</span><br><span class="line">	state[<span class="number">3</span>] += d;</span><br><span class="line">	<span class="built_in">memset</span> ((POINTER)x, <span class="number">0</span>, <span class="keyword">sizeof</span> (x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MD5Init</span><span class="params">(MD5_CTX *context)</span> </span>&#123;</span><br><span class="line">	context-&gt;count[<span class="number">0</span>] = context-&gt;count[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	context-&gt;state[<span class="number">0</span>] = <span class="number">0x67452301</span>;</span><br><span class="line">	context-&gt;state[<span class="number">1</span>] = <span class="number">0xefcdab89</span>;</span><br><span class="line">	context-&gt;state[<span class="number">2</span>] = <span class="number">0x98badcfe</span>;</span><br><span class="line">	context-&gt;state[<span class="number">3</span>] = <span class="number">0x10325476</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MD5Update</span><span class="params">(MD5_CTX *context, <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">unsigned</span> <span class="keyword">int</span> inputLen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, index, partLen;</span><br><span class="line"></span><br><span class="line">	index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((context-&gt;count[<span class="number">0</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x3F</span>);</span><br><span class="line">	<span class="keyword">if</span> ((context-&gt;count[<span class="number">0</span>] += ((UINT4)inputLen &lt;&lt; <span class="number">3</span>))</span><br><span class="line">	        &lt; ((UINT4)inputLen &lt;&lt; <span class="number">3</span>))</span><br><span class="line">		context-&gt;count[<span class="number">1</span>]++;</span><br><span class="line">	context-&gt;count[<span class="number">1</span>] += ((UINT4)inputLen &gt;&gt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line">	partLen = <span class="number">64</span> - index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inputLen &gt;= partLen) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen);</span><br><span class="line">		MD5Transform(context-&gt;state, context-&gt;buffer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = partLen; i + <span class="number">63</span> &lt; inputLen; i += <span class="number">64</span>)</span><br><span class="line">			MD5Transform (context-&gt;state, &amp;input[i]);</span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MD5Final</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> digest[<span class="number">16</span>], MD5_CTX *context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> bits[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> index, padLen;</span><br><span class="line"></span><br><span class="line">	Encode (bits, context-&gt;count, <span class="number">8</span>);</span><br><span class="line">	index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((context-&gt;count[<span class="number">0</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">	padLen = (index &lt; <span class="number">56</span>) ? (<span class="number">56</span> - index) : (<span class="number">120</span> - index);</span><br><span class="line">	MD5Update (context, PADDING, padLen);</span><br><span class="line">	MD5Update (context, bits, <span class="number">8</span>);</span><br><span class="line">	Encode (digest, context-&gt;state, <span class="number">16</span>);</span><br><span class="line">	<span class="built_in">memset</span> ((POINTER)context, <span class="number">0</span>, <span class="keyword">sizeof</span> (*context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MD5Digest</span><span class="params">(<span class="keyword">char</span> *pszInput, <span class="keyword">unsigned</span> <span class="keyword">long</span> nInputSize, <span class="keyword">char</span> *pszOutPut)</span> </span>&#123;</span><br><span class="line">	MD5_CTX context;</span><br><span class="line"></span><br><span class="line">	MD5Init (&amp;context);</span><br><span class="line">	MD5Update (&amp;context, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)pszInput, nInputSize);</span><br><span class="line">	MD5Final ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)pszOutPut, &amp;context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szDigest[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">char</span> encrypt[MAX_SIZE];</span><br><span class="line"></span><br><span class="line">	FILE *fp = fopen(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> size = ftell(fp);</span><br><span class="line"></span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(encrypt, <span class="number">0</span>, <span class="keyword">sizeof</span>(encrypt));</span><br><span class="line">	<span class="keyword">int</span> len = fread(encrypt, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), size, fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;size:%d,len:%d\n&quot;</span>, size, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nencrytion:&quot;</span>);</span><br><span class="line">	MD5Digest(encrypt, size,szDigest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%02X&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)szDigest[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-堆排序</title>
    <url>/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>思想：将无序的数列构造成大顶堆，此时堆的根节点就是整个数列中最大的值，将此时的根节点与堆中最后一个元素交换，将根节点拿出来。再对此时的数列进行重新构造大顶堆。依次操作，直至构造的堆只有一个元素，即数列的最小的数。</strong><span id="more"></span></p>
<p><strong>例子：如有数组tree{2,5,3,1,10,4}</strong></p>
<p><strong>先对数列构造大顶堆，对数列构造完全二叉树，从树的倒数第二层对树的节点进行heapify操作（即对于有子节点的结点，将结点的值与其子节点的值比较，如果该结点的值比子节点小，结点的值就与子节点的值交换，如图3.1所示），直至完全二叉树的根节点结束。这样就成功构造出大顶堆。</strong></p>
<p><strong>前四趟堆排序，先构造大顶堆，在交换值，取值拿出如图 3.2所示：</strong> </p>
<p>  <img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/3.2.1.jpg" alt="3.2"><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/3.2.2.png" alt="3.2"><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/3.2.3.png" alt="3.2"><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/3.2.4.png" alt="3.2"></p>
<center>图3.2：堆排序前四趟过程图</center>

<p><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/3.1.png" alt="3.1"></p>
<center>图3.1：heapify操作过程图</center>

<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先进行heapify，使父节点最大，如，根节点 5 左右节点 6 9 那么就将子节点9与父节点5交换形成堆</span></span><br><span class="line"><span class="comment">//对于一个完全二叉树，从倒数第二层进行heapify,直到根节点，让完全二叉树形成堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=tree[i];</span><br><span class="line">	tree[i]=tree[j];</span><br><span class="line">	tree[j]=temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *tree[]:数组或者说一棵树</span></span><br><span class="line"><span class="comment"> *n:树里面有多少个结点</span></span><br><span class="line"><span class="comment"> *i:树里第几个结点 </span></span><br><span class="line"><span class="comment"> *c1&lt;n和c2&lt;n 判断是否出界 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=i) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> c1=(<span class="number">2</span>*i)+<span class="number">1</span>;<span class="comment">//第i个结点的左子节点 </span></span><br><span class="line">	<span class="keyword">int</span> c2=(<span class="number">2</span>*i)+<span class="number">2</span>; <span class="comment">//第i个结点的右子节点</span></span><br><span class="line">	<span class="comment">//从三个结点中找出最大值</span></span><br><span class="line">	<span class="keyword">int</span> max=i;</span><br><span class="line">	<span class="keyword">if</span>(c1&lt;n &amp;&amp; tree[max]&lt;tree[c1])&#123;</span><br><span class="line">		max=c1;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c2&lt;n &amp;&amp; tree[max]&lt;tree[c2])&#123;</span><br><span class="line">		max=c2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果最大值的结点不是第i个结点，就交换值 </span></span><br><span class="line">	<span class="keyword">if</span>(max != i)&#123;</span><br><span class="line">		<span class="comment">//交换两个结点</span></span><br><span class="line">		swap(tree,max,i); </span><br><span class="line">		<span class="comment">//对下面节点继续做heapify </span></span><br><span class="line">		heapify(tree,n,max);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last_node=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> parent = (last_node<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=parent;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		heapify(tree,n,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序，树经过heapify操作后，保证了根节点是堆中最大的数</span></span><br><span class="line"><span class="comment">//将根节点与最后与一个结点交换，拿出根节点</span></span><br><span class="line"><span class="comment">//交换最后一个结点，拿出根节点后，再对当前数进行heapify操作</span></span><br><span class="line"><span class="comment">//按此步骤继续，直至取到只剩一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	build_heap(tree,n);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="comment">//每次交换根节点和最后一个结点</span></span><br><span class="line">	</span><br><span class="line">		swap(tree,i,<span class="number">0</span>);</span><br><span class="line">		heapify(tree,i,<span class="number">0</span>); 	<span class="comment">//printf(&quot;%d &quot;,tree[i]);</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tree[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;堆排序\n请输入数组长度：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整型数据：\n&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	heap_sort(tree,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;堆排序结果：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-广搜</title>
    <url>/2021/04/09/%E7%AE%97%E6%B3%95-%E5%B9%BF%E6%90%9C/</url>
    <content><![CDATA[<h4 id="广度优先搜索bfs"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h4><p><strong>基本思想：广度优先搜索是最简便的图的搜索算法之一，层层遍历，不考虑结果可能出现的位置，彻底遍历完整张图，直至找到结果。</strong></p>
<span id="more"></span>![3.1](/6.png)

<p><strong>演示：若A为开始的点，就将A先压入队列，遍历与A相邻的点，A出队，BCD入队，遍历B点的相邻的点，B出队，E入队。此时队列为CDE，遍历与C相邻的点，C出队，F入队。此时队列为DEF，遍历与D相邻的点，D出队，G入队。此时队列为EFG,遍历与E相邻的点，E没有相邻的点，E出队。此时队列为FG，遍历与F相邻的点，F出队，H入队。此时队列为GH，遍历与G相邻的点，由于H和D都已经被遍历过，所有不存在与G相邻且没有遍历过的点，G出队。此时队列为H，遍历与H相邻的点，不存在与H相邻且没有遍历过的点，H出队。所以图6用广度优先搜索的顺序是ABCDEFGH。</strong></p>
<p><strong>示例：迷宫最短路径问题</strong></p>
<p><strong>分析：从开始点遍历点的上下左右并过滤非通路的点，且对已遍历的点标记和记录通路点到起点的位置，选择一个通路的点遍历该点的上下左右，如此循环直至找到迷宫终点。广度优先一层层扩散，第一次寻找到终点即最短的路径。</strong></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *宽度有限搜索</span></span><br><span class="line"><span class="comment"> *迷宫最短路径问题，起始点为S，结束点为G 二维图形有</span></span><br><span class="line"><span class="comment">  m=10 n=10；</span></span><br><span class="line"><span class="comment">#S######.#</span></span><br><span class="line"><span class="comment">......#..#</span></span><br><span class="line"><span class="comment">.#.##.##.#</span></span><br><span class="line"><span class="comment">.#........</span></span><br><span class="line"><span class="comment">##.##.####</span></span><br><span class="line"><span class="comment">....#....#</span></span><br><span class="line"><span class="comment">.#######.#</span></span><br><span class="line"><span class="comment">....#.....</span></span><br><span class="line"><span class="comment">.####.###.</span></span><br><span class="line"><span class="comment">....#...G#</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX =<span class="number">100</span>;</span><br><span class="line"><span class="comment">//迷宫的二维图像数组</span></span><br><span class="line"><span class="keyword">char</span> maze[MAX][MAX+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;<span class="comment">//几行几列</span></span><br><span class="line"><span class="keyword">int</span> sx,sy;<span class="comment">//起点坐标</span></span><br><span class="line"><span class="keyword">int</span> gx,gy;<span class="comment">//终点坐标</span></span><br><span class="line"><span class="comment">//上下左右</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//记录当前遍历点的坐标，及该点到起始点的距离 </span></span><br><span class="line"><span class="keyword">int</span> d[MAX][MAX+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//广度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="comment">//定义队列que</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;P&gt; que;</span><br><span class="line">	<span class="comment">//寻找起始坐标</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(maze[i][j ]== <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				sx = i;</span><br><span class="line">				sy=j;	<span class="comment">//赋值下标</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(maze[i][j] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">				gx = i;</span><br><span class="line">				gy = j;	<span class="comment">//赋值下标</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *将数组d初始化为无穷大</span></span><br><span class="line"><span class="comment">	 *作用1：d数组记录这个点到开始点的最小步数</span></span><br><span class="line"><span class="comment">	 *作用2：d数组标记这个点是否被遍历过，如果为值为无穷大就代表这个点没有被遍历过</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="comment">//将初始转态压入队列</span></span><br><span class="line">	que.push(P(sx,sy));</span><br><span class="line">	<span class="comment">//初始化距离为0； </span></span><br><span class="line">	d[sx][sy] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(que.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> i; </span><br><span class="line">		<span class="comment">//取出队头</span></span><br><span class="line">		P p = que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="comment">//移动位置nx,ny</span></span><br><span class="line">		<span class="keyword">int</span> nx = p.first;</span><br><span class="line">		<span class="keyword">int</span> ny = p.second;</span><br><span class="line">		<span class="keyword">if</span>(nx == gx &amp;&amp; ny == gy) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//遍历点的上下左右</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">			<span class="comment">//移动后的位置记为（nx,ny）</span></span><br><span class="line">			nx = p.first + dx[i];</span><br><span class="line">			ny = p.second + dy[i];</span><br><span class="line">			<span class="comment">//限制边界，查看点是否遍历过，查看点是否是通路的点 </span></span><br><span class="line">			<span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; d[nx][ny] == INF &amp;&amp; maze[nx][ny] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				<span class="comment">//如果该点合法 d数组值加一 </span></span><br><span class="line">				d[nx][ny] = d[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//把该点压入队列 </span></span><br><span class="line">				que.push(P(nx,ny));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[gx][gy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;maze[i];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-归并排序</title>
    <url>/2021/04/09/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>分治思想、二路归并。</p>
<ol>
<li><p>将数列从中间分开，对两边排序。</p>
</li>
<li><p>将两个有序数组进行合并。</p>
<span id="more"></span></li>
</ol>
<p>例子：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>4</td>
<td>6</td>
<td>3</td>
<td>8</td>
<td>2</td>
<td>5</td>
<td>7</td>
</tr>
</tbody></table>
<p><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.1.png" alt="2.1"></p>
<center>过程图2.1</center>

<p><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.2.png" alt="2.1"></p>
<center>过程图2.2</center>

<p>第一趟归并后</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>10</td>
<td>3</td>
<td>6</td>
<td>2</td>
<td>8</td>
<td>5</td>
<td>7</td>
</tr>
</tbody></table>
<p>第二趟归并后</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>6</td>
<td>10</td>
<td>2</td>
<td>5</td>
<td>7</td>
<td>8</td>
</tr>
</tbody></table>
<p>第三趟归并后</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>10</td>
</tr>
</tbody></table>
<p>具体过程如2.2 ：数组先往左分，直至不可再分即“[0]”，再返回上一个结点即“[0,1]”，再将“[0,1]”往右分，直至不可再分即“[1]”,“[0,1]”结点左右分完以后或者说往右分的“[1]”结点不可再分就对“[0,1]”的左右结点进行二路归并，即将“[0]”“[1]”排序合并。</p>
<p>“[0,1]”结点左右分完，再返回上上个结点即“[0,3]”，对“[0,3]”结点往左分，往左分完，在往右分，分完在合并，重复上述操作，直至所有结点分完且合并。最终归为一个父节点即“[0,7]”，输出结果。</p>
<p>总结对一个结点左右皆不可再分或已经分过进行归并，优先级先分左边再分右边，分完左右排序合并。</p>
<p>细节：mergeSort(a,s,e); “a”指数列数组，”s”指数组首地址，”e”指数组尾地址。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LEFT_SIZE=m-l;<span class="comment">//left[]的长度 </span></span><br><span class="line">	<span class="keyword">int</span> RIGHT_SIZE=r-m+<span class="number">1</span>;<span class="comment">//right[]的长度 </span></span><br><span class="line">	<span class="comment">//a[5]=&#123;1,2,5,3,1&#125;</span></span><br><span class="line">	<span class="keyword">int</span> left[LEFT_SIZE];</span><br><span class="line">	<span class="keyword">int</span> right[LEFT_SIZE];</span><br><span class="line">	<span class="keyword">int</span> i,k,j;</span><br><span class="line">	<span class="comment">//将数组分成左右两个数组 </span></span><br><span class="line">	<span class="keyword">for</span>(i=l;i&lt;=m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		left[i-l]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=m;i&lt;=r;i++)&#123;</span><br><span class="line">		right[i-m]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	i=<span class="number">0</span>;<span class="comment">//&#x27;i&#x27;,指left[]的首地址 </span></span><br><span class="line">	j=<span class="number">0</span>;<span class="comment">//&#x27;j&#x27;,指right[]的首地址 </span></span><br><span class="line">	k=l;<span class="comment">//&#x27;k&#x27;,指a[]的首地址</span></span><br><span class="line">	/</span><br><span class="line">	 把left[]和right[]重新有序地放到a[]中 </span><br><span class="line">	 / </span><br><span class="line"></span><br><span class="line">	 <span class="comment">//如果right[]和left[]数组中都存在着数据，那么比较 </span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;LEFT_SIZE&amp;&amp;j&lt;RIGHT_SIZE)&#123;</span><br><span class="line">		<span class="keyword">if</span>(left[i]&lt;right[j])&#123;</span><br><span class="line">			a[k]=left[i];</span><br><span class="line">			i++;k++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			a[k]=right[j];</span><br><span class="line">			j++;k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果比较完以后，left[]数组中仍存在数据，就依次放入a[]数组中 </span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;LEFT_SIZE)&#123;</span><br><span class="line">		a[k]=left[i];i++;k++;&#125;</span><br><span class="line">	<span class="comment">//如果比较完以后，right[]数组中仍存在数据，就依次放入a[]数组中 </span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;RIGHT_SIZE)&#123;</span><br><span class="line">		a[k]=right[j];</span><br><span class="line">		j++;k++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int t=0;t&lt;LEFT_SIZE;t++)</span></span><br><span class="line"><span class="comment">//		printf(&quot;%d &quot;,left[t]);	</span></span><br><span class="line"><span class="comment">//	printf(&quot; sdfadf &quot;,a[r]);</span></span><br><span class="line"><span class="comment">//	for(int t=0;t&lt;RIGHT_SIZE;t++)</span></span><br><span class="line"><span class="comment">//		printf(&quot;%d &quot;,right[t]);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(r+l)/<span class="number">2</span>;</span><br><span class="line">			</span><br><span class="line">		mergesort(a,l,m);</span><br><span class="line">		mergesort(a,m+<span class="number">1</span>,r);</span><br><span class="line">		/</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=l;t&lt;=m;t++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[t]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; sdfadf &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=m+<span class="number">1</span>;t&lt;=r;t++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[t]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		/</span><br><span class="line">	merge(a,l,m+<span class="number">1</span>,r);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n,i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;合并排序\n请输入数组长度：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整型数据：\n&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>;<span class="comment">//l首地址 </span></span><br><span class="line">	<span class="keyword">int</span> r=n<span class="number">-1</span>;<span class="comment">//r尾地址 </span></span><br><span class="line">	mergesort(a,l,r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序结果：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-快速排序</title>
    <url>/2021/04/09/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>分治思想，也可以理解为二分。</p>
<p>1．先从数列中取出一个数作为基准数。 </p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<span id="more"></span>

<p>例子：（基准值k始终为循环数组的第一个值）定义数组为a[]，最小下标为s，最大下标为e，快速排序quicksort(int a[],int s,int e);</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>72</td>
<td>6</td>
<td>57</td>
<td>88</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>48</td>
<td>85</td>
</tr>
</tbody></table>
<p>初始值，i=0,j=9,k=a[i]=72</p>
<p>第一趟排序从j开始往前找一个比k小的数替换，即j=8,a[0]与a[8]交换值，i++，</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>88</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>72</td>
<td>85</td>
</tr>
</tbody></table>
<p>接着再找比a[8]小的值，这次从i=0开始往后找一个比a[8]（a[8]=72）大的值替换，即i=3,a[8]与a[3]交换值，j–。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>88</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>72</td>
<td>85</td>
</tr>
</tbody></table>
<p>此时数组数值：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>72</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>88</td>
<td>85</td>
</tr>
</tbody></table>
<p>此时i=3,j=7,k=a[3]=72，重复上一步操作，从j开始往前找一个比a[3]小的数替换，即j=5,a[3]与a[5]交换值，i++，</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>72</td>
<td>60</td>
<td>42</td>
<td>83</td>
<td>73</td>
<td>88</td>
<td>85</td>
</tr>
</tbody></table>
<p>接着从i=3往后找比a[5]（a[5]=72）大的值替换，由于i=j=5,退出循环。第一趟排序结束，此时数组数值：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>42</td>
<td>60</td>
<td>72</td>
<td>83</td>
<td>73</td>
<td>88</td>
<td>85</td>
</tr>
</tbody></table>
<p>第一趟排序结束，最终结果：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>6</td>
<td>57</td>
<td>42</td>
<td>60</td>
<td>72</td>
<td>83</td>
<td>73</td>
<td>88</td>
<td>85</td>
</tr>
</tbody></table>
<p>k左面的任意一个值小于k右面的任意一个值，即（left&lt;=k&lt;=right）。</p>
<p>第二趟分别对left或right进行上述排序（left和right可以看成两个数组进行排序）。对left，此时i=0,j=4（即上一趟循环后i或j的值减一），k=a[0];对right，此时i=5（即上一趟循环后i或j的值加一），j=9,k=[5]。即重复调用quicksort(a,s,i-1)和quicksort(a,i+1,e)或者quicksort(a,s,j-1)和quicksort(a,j+1,e)。</p>
<p>注：基准值的选取是不定的，虽然说无论怎么选取基准值，都不会影响最终的排序结果，但是实际应根据输入的数列特征而改变，以此保证快速排序的效率。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,number;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	t=b;</span><br><span class="line">	b=c;</span><br><span class="line">	c=t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s&gt;=e) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i=s;</span><br><span class="line">	<span class="keyword">int</span> j=e;</span><br><span class="line">	<span class="keyword">int</span> k=a[s];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;=k)</span><br><span class="line">			j--;</span><br><span class="line">		swap(&amp;a[i],&amp;a[j]);</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=k)</span><br><span class="line">			i++;</span><br><span class="line">		swap(&amp;a[i],&amp;a[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	/</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	/</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	quicksort(a,s,i<span class="number">-1</span>);</span><br><span class="line">	quicksort(a,i+<span class="number">1</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	m=<span class="number">0</span>;</span><br><span class="line">	number=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;快速排序\n请输入数组长度：\n&quot;</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整型数据：\n&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	quicksort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序结果：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-最小生成树</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><strong>概念：保持图连通的最少边的树称为生成树，n个结点的生成树，有n-1条边，当边的权值和最小称为最小生成树，也称最小权值生成树。</strong></p>
<span id="more"></span>

<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>概念：并查集是一种树型的数据结构，用于处理一些不相交</strong><a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117"><strong>集合</strong></a><strong>（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</strong></p>
<p><strong>理解：并查集，集指集合；查指查找元素所在的集合，即元素最终的根节点；并将两个元素所在的集合合并为一个集合，前提需要判断两个元素是否属于同一个集合。</strong></p>
<p><strong>示例：检查一个图中存不存在环如图：</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/8.1.png" alt="8.1"></p>
<p><strong>过程：创建一个数组parent[]表示该结点的父节点如表所示</strong></p>
<table>
<thead>
<tr>
<th><strong>结点</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Parent</strong></td>
<td><strong>1</strong></td>
<td><strong>-1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td><strong>2</strong></td>
</tr>
</tbody></table>
<p><strong>创建parent[]数组是为了查找某一节点的根节点是哪个，这样就可以判断任意两个结点在不在同一集合里，因为我们只需要一层层查找他们的根节点，找到最终的根节点，判断是否相同就行了。相同说明这两个结点在同一个集合里。创建一个find_root()函数查找节点的最终根节点。</strong></p>
<p><strong>若将俩个集合合并在一起，只需要将两个集合的根节点任意一个设置为另一个的根节点就行了。</strong></p>
<p><strong>压缩路径：为了使树的高度不呈直线的形式上升，压缩路径。但合并集合时，比较x和y节点集合树的高度，高度低的一方向高度高的一方合并。</strong></p>
<p><strong>示例代码:union.cpp union2.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的数量 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTICES 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化parent[]数组 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initialise</span><span class="params">(<span class="keyword">int</span> parent[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;VERTICES;i++)&#123;</span><br><span class="line">		parent[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找顶点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root=x;</span><br><span class="line">	<span class="keyword">while</span>(parent[x_root]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		x_root=parent[x_root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个集合 返回1成功，返回0合并失败（两个顶点在一个集合中） </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union_vertices</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root=find_root(x,parent);</span><br><span class="line">	<span class="keyword">int</span> y_root=find_root(y,parent);</span><br><span class="line">	<span class="keyword">if</span>(x_root==y_root) &#123;<span class="comment">//如果两个结点的根是同一个 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//否则将两树合并成一个树 </span></span><br><span class="line">		parent[x_root]=y_root; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent[VERTICES]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">//图 6条边，每条边连接两个顶点 </span></span><br><span class="line">	<span class="keyword">int</span> edges[<span class="number">5</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line">	&#125; ;</span><br><span class="line">	</span><br><span class="line">	initialise(parent);<span class="comment">//初始化parent数组，全为-1 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = edges[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> y = edges[i][<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(union_vertices(x,y,parent)==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Cycle existence!&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No Cycle found!&quot;</span>) ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>示例代码:union2.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的数量 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTICES 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化parent[]数组 rank[]记录数的高度 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initialise</span><span class="params">(<span class="keyword">int</span> parent[],<span class="keyword">int</span> rank[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;VERTICES;i++)&#123;</span><br><span class="line">		parent[i]=<span class="number">-1</span>;</span><br><span class="line">		rank[i]=<span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找顶点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root=x;</span><br><span class="line">	<span class="keyword">while</span>(parent[x_root]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		x_root=parent[x_root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个集合 返回1成功，返回0合并失败（两个顶点在一个集合中） </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union_vertices</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> parent[],<span class="keyword">int</span> rank[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root=find_root(x,parent);</span><br><span class="line">	<span class="keyword">int</span> y_root=find_root(y,parent);</span><br><span class="line">	<span class="keyword">if</span>(x_root==y_root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//压缩路径 </span></span><br><span class="line">		<span class="keyword">if</span>(rank[x_root]&gt;rank[y_root])&#123;</span><br><span class="line">			parent[y_root]=x_root; </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(rank[y_root]&gt;rank[x_root])&#123;</span><br><span class="line">				parent[x_root]=y_root;	</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				parent[x_root]=y_root;</span><br><span class="line">				rank[y_root]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent[VERTICES];</span><br><span class="line">	<span class="keyword">int</span> rank[VERTICES];</span><br><span class="line">	<span class="comment">//图 6条边，每条边连接两个顶点 </span></span><br><span class="line">	<span class="keyword">int</span> edges[<span class="number">6</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	initialise(parent,rank);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = edges[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> y = edges[i][<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(union_vertices(x,y,parent,rank)==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Cycle existence!&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No Cycle found!&quot;</span>) ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-深搜</title>
    <url>/2021/04/09/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9C/</url>
    <content><![CDATA[<h4 id="深度优先搜索dfs"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>概念思想：DFS属于图算法的一种，从一个顶点开始向下搜索没有遍历过的结点，直至不能再深入为止，且每个结点只能遍历一次。</p>
<span id="more"></span>

<p>例子解释：如图从A结点开始深搜，遍历的过程为：A-&gt;D-&gt;G-&gt;H-&gt;C-&gt;F-&gt;B-E</p>
<p><img src="/2021/04/09/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9C/3.png" alt="3.1"></p>
<p><strong>对二维网络进行深度优先搜索，遇到1则向其八个方向搜索，其他八个方向也有1则以这个点为原点向它的八个方向搜索，已经遍历过的点，不再遍历。直至遍历的都为0，则在返回上一个点，换个方向继续搜索，如例子解释的遍历方式一样。如例题遍历到的第一个1数组下标为[1,4]，从这个点的上方开始围绕着这个点其它八个方向的点遍历，遍历到右边是遇到第二个为1的点数组下标[1,5],继续上述操作。即遍历一次经[1,4]-&gt;[1,5]-&gt;[2,6]-&gt;[2,5]-&gt;[2,4]-&gt;[2,3]。</strong></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//多少岛屿及最大岛屿问题 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 16</span></span><br><span class="line"><span class="comment">0000000000000000</span></span><br><span class="line"><span class="comment">0000110011000000</span></span><br><span class="line"><span class="comment">0001111000111000</span></span><br><span class="line"><span class="comment">0000000000000000</span></span><br><span class="line"><span class="comment">0011111100000110</span></span><br><span class="line"><span class="comment">0011100000000000</span></span><br><span class="line"><span class="comment">0100001111111100</span></span><br><span class="line"><span class="comment">0000000000000000</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, c, max;<span class="comment">//c:面积 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[x][y]==<span class="number">0</span>)	</span><br><span class="line">		<span class="keyword">return</span>;	</span><br><span class="line">	c ++;	</span><br><span class="line">	a[x][y] = <span class="number">0</span>;</span><br><span class="line">	dfs(x,y+<span class="number">1</span>);	</span><br><span class="line">	dfs(x,y<span class="number">-1</span>);	</span><br><span class="line">	dfs(x<span class="number">-1</span>,y);	</span><br><span class="line">	dfs(x+<span class="number">1</span>,y);	</span><br><span class="line">	dfs(x+<span class="number">1</span>,y+<span class="number">1</span>);	</span><br><span class="line">	dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);	</span><br><span class="line">	dfs(x<span class="number">-1</span>,y+<span class="number">1</span>);	</span><br><span class="line">	dfs(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k, i, j, sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;求二维网络岛屿数及最大岛屿面积，0代表海域，1代表岛屿\n&quot;</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入行列值：&quot;</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入由0和1组成的%d行%d列的二维网络\n&quot;</span>,n,m);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j ++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i  ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">				sum ++;</span><br><span class="line">				c = <span class="number">0</span>;</span><br><span class="line">				dfs(i,j);</span><br><span class="line">				<span class="keyword">if</span>(c &gt; max)</span><br><span class="line">					max = c ;	</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;岛屿总数量为：%d，最大岛屿面积为：%d\n&quot;</span>,sum,max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-贪心</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p><strong>前提：问题的全局最优解可以通过一步步获得多个局部最优解获得，问题必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</strong></p>
<p><strong>基本思想：根据某个优化策略，每一步确保获得局部最优解，直至达到终止条件。</strong></p>
<span id="more"></span>

<p><strong>示例：背包问题。有一个背包，背包容量是M=19kg。有6个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</strong></p>
<p><strong>物品 A B C D E F</strong></p>
<p><strong>重量 2kg 6kg 7kg 4kg 10kg 3kg价值 8$ 1$ 9$ 4$ 2$ 4$</strong></p>
<p><strong>分析：每次优先装载单位重量价值最大的物品</strong></p>
<p><strong>示例代码：greedy.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//背包问题，可分割（贪心算法） </span></span><br><span class="line"><span class="comment">//背包能装mkg,总共有n个物品，每个物品价值不同，物质可以分割  </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 19 </span></span><br><span class="line"><span class="comment">2 8 </span></span><br><span class="line"><span class="comment">6 1 </span></span><br><span class="line"><span class="comment">7 9</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">10 2</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp=n;</span><br><span class="line">	n=m;</span><br><span class="line">	m=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> arr[],<span class="keyword">int</span> a[],<span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	<span class="keyword">int</span> temp1;<span class="keyword">int</span> temp2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&lt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">				temp=arr[j];</span><br><span class="line">				arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">				arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				temp1=a[j];</span><br><span class="line">				a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>]=temp1;</span><br><span class="line">				temp2=b[j];</span><br><span class="line">				b[j]=b[j+<span class="number">1</span>];</span><br><span class="line">				b[j+<span class="number">1</span>]=temp2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> a[],<span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> c[n],sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		c[i]=<span class="keyword">float</span>(b[i])/<span class="keyword">float</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据物品单位重量价值从大到小排序 </span></span><br><span class="line">	sort(n,c,a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %.2f\n&quot;</span>,a[i],b[i],c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&gt;=a[i]) &#123;	 <span class="comment">//如果物品重量小于背包剩余承重 </span></span><br><span class="line">			m=m-a[i];	 <span class="comment">//装载物品后，背包剩余重量 </span></span><br><span class="line">			sum=sum+b[i]; <span class="comment">//背包物品的总价值 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;            <span class="comment">//物品重量大于背包剩余承重 </span></span><br><span class="line">			sum = sum+m*c[i];</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入物品数量：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入背包承重：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a[n],b[n];<span class="comment">//a[n]：物品重量；b[n]: 物品价值 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入物品重量和价值：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">	<span class="keyword">float</span> sum = greedy(n,m,a,b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,sum);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>示例：****用贪心算法解决活动安排问题：设有待安排的 10 项活动，都要使用某一公共资源，每项活动的开始时间和结束时间如下表所示</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
<th><strong>8</strong></th>
<th><strong>9</strong></th>
<th><strong>10</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开始时间</strong></td>
<td><strong>3</strong></td>
<td><strong>0</strong></td>
<td><strong>9</strong></td>
<td><strong>1</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
<td><strong>2</strong></td>
<td><strong>5</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>结束时间</strong></td>
<td><strong>8</strong></td>
<td><strong>6</strong></td>
<td><strong>13</strong></td>
<td><strong>4</strong></td>
<td><strong>13</strong></td>
<td><strong>12</strong></td>
<td><strong>3</strong></td>
<td><strong>10</strong></td>
<td><strong>5</strong></td>
<td><strong>9</strong></td>
</tr>
</tbody></table>
<p><strong>求安装排最多的活动。</strong></p>
<p><strong>分析：每次选择结束最早的活动，就能保住安排尽可能多的活动。先对每个活动安照结束时间排序，下一次选择的活动的开始时间必须不小于上一次活动的结束时间，按照此条件，顺序地遍历按结束时间排序后的活动，挑选出满足start_time[i+1]&gt;=end_time[i]的活动。</strong></p>
<p><strong>示例代码：****greedy1.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*活动开始时间和结束时间 ，共十个活动 </span><br><span class="line">3 8</span><br><span class="line">0 6</span><br><span class="line">9 13</span><br><span class="line">1 4</span><br><span class="line">10 13</span><br><span class="line">11 12</span><br><span class="line">2 3</span><br><span class="line">5 10</span><br><span class="line">3 5</span><br><span class="line">4 9</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct action&#123;</span><br><span class="line">	int start;&#x2F;&#x2F;活动开始时间 </span><br><span class="line">	int end;&#x2F;&#x2F;活动结束时间 </span><br><span class="line">	int index;&#x2F;&#x2F;活动编号 </span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(const action &amp;a, const action &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a.end&lt;&#x3D;b.end) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void greedy(int n,action a[])&#123;</span><br><span class="line">	printf(&quot;\n按活动结束时间排序后：\n&quot;);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">			printf(&quot;%d %d\n&quot;,a[i].start,a[i].end);</span><br><span class="line">		&#125; </span><br><span class="line">	int v &#x3D; 0;</span><br><span class="line">	printf(&quot;\n%d %d\n&quot;,a[0].index,a[0].start,a[0].end);</span><br><span class="line">	for(int i&#x3D;1;i&lt;n-1;i++)&#123;</span><br><span class="line">		&#x2F;&#x2F;如果下一个活动的开始时间不小于上一个活动的开始时间 </span><br><span class="line">		if(a[i].start &gt;&#x3D; a[v].end)&#123;</span><br><span class="line">			v&#x3D;i;</span><br><span class="line">			printf(&quot;%d %d\n&quot;,a[i].start,a[i].end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	action a[100];</span><br><span class="line">	int n;</span><br><span class="line">	cout&lt;&lt;&quot;请输入活动数量：&quot;; </span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;&quot;请输入活动的开始时间及结束时间：&quot;&lt;&lt;endl; </span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].start&gt;&gt;a[i].end;</span><br><span class="line">		a[i].index&#x3D;i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n,cmp);</span><br><span class="line">	greedy(n,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-递归与回溯</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><strong>程序调用自身。构成递归构成的条件：</strong></p>
<p><strong>（1）子问题与原始问题为相同的事，且更为简单</strong></p>
<p><strong>（2）不能无限调用本身，必须有一个出口</strong></p>
<span id="more"></span>

<p><strong>递归最经典的案例：斐波纳契数数列（黄金分割数列）。</strong></p>
<p><strong>缺点：执行效率低，一般情况下应尽量避免使用递归</strong></p>
<p><strong>示例：一个数的阶乘；两个数的最大公约数；n阶台阶几种走法；一个集合的子集</strong></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//求一个数的阶乘</span></span><br><span class="line"><span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	s*=n;</span><br><span class="line">	jc(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jc1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n*jc1(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求一个数的最大公约数（辗转相除）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gy</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a%b==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="comment">//a%b=c;a=b;b=c;</span></span><br><span class="line">	<span class="keyword">return</span> gy(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果共有n阶台阶，一次可以走一阶或两阶，求有多少种走法？</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> tj(n<span class="number">-1</span>)+tj(n<span class="number">-2</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//求一个集合的子集</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&#123;&quot;</span>) ;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&#125;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recurtion</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		 display(a);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		arr[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">	    recurtion(a,n<span class="number">-1</span>);</span><br><span class="line">	    arr[n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">		recurtion(a,n<span class="number">-1</span>);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;递归\n&quot;</span>); </span><br><span class="line">	<span class="comment">//求一个集合的子集</span></span><br><span class="line">		<span class="comment">//printf(&quot;&#123;&quot;) ;	</span></span><br><span class="line">		<span class="comment">//recurtion(a,3);printf(&quot;&#125;&quot;); </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求一个数的阶乘</span></span><br><span class="line">		<span class="comment">//printf(&quot;%d&quot;,jc1(5)); </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求两个数的最大公约数</span></span><br><span class="line">		<span class="comment">//printf(&quot;%d&quot;,gy(319,377)) ;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果共有n阶台阶，一次可以走一阶或两阶，求有多少种走法</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,tj(<span class="number">10</span>)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p><strong>基本思想：从一条路往前走，能进则进，不能进则退回来，换一条路再试，（能进则进）。回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。</strong></p>
<p><strong>用回溯算法解决问题的一般步骤：</strong></p>
<p><strong>1、针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</strong></p>
<p><strong>2、确定易于搜索的解空间结构,使得能用<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯法</a>方便地搜索整个解空间。</strong></p>
<p><strong>3、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</strong></p>
<p><strong>示例：八皇后问题</strong></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;八皇后问题</span><br><span class="line">&#x2F;*</span><br><span class="line"> *在8x8的棋盘上合法放置八个皇后，即每个皇后不和其他皇后在同一列、行和对角线上</span><br><span class="line"> *方法：回溯（确定每一行只能放置一个皇后，且合法，遍历每一行位置放置皇后，直至放置八个为止）</span><br><span class="line"> *返回上一层选择不同的位置放置皇后，直至到第一次的所有位置，即穷举所有可能。 </span><br><span class="line">*&#x2F; </span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int solution&#x3D;0;&#x2F;&#x2F;方案</span><br><span class="line">int arr[8][8]; &#x2F;&#x2F;棋盘</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查点是否合法（即是否存在其他的皇后在该点所在的列、行、左右对角线 ）</span><br><span class="line">int check(int i, int j)&#123; &#x2F;&#x2F;i行j列 </span><br><span class="line">	int k,h;</span><br><span class="line">	&#x2F;&#x2F;判断列是否合法（遍历每层只放一个皇后，所有不用再重复检查一行是否有其他皇后）</span><br><span class="line">	for(k &#x3D; 0; k &lt; 8 ; k ++)&#123;</span><br><span class="line">		if(arr[k][j] &#x3D;&#x3D; 1)&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	&#x2F;&#x2F;判断左对角线是否合法</span><br><span class="line">	for(k &#x3D; i - 1,h &#x3D; j - 1; k &gt;&#x3D; 0 &amp;&amp; h &gt;&#x3D; 0; k --, h--)&#123;</span><br><span class="line">		if(arr[k][h] &#x3D;&#x3D; 1)&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	&#x2F;&#x2F;判断右对角线是否合法</span><br><span class="line">	for(k &#x3D; i - 1,h &#x3D; j + 1; k &gt;&#x3D; 0 &amp;&amp; h &lt; 8; k --, h ++)&#123;</span><br><span class="line">		if(arr[k][h] &#x3D;&#x3D; 1)&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	return 1;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;放置皇后,i指棋盘层数 </span><br><span class="line">void queen(int i) &#123;</span><br><span class="line">	int j;</span><br><span class="line">	if(i &gt; 7)&#123;</span><br><span class="line">		solution ++; </span><br><span class="line">		return ;</span><br><span class="line">	&#125; </span><br><span class="line">	&#x2F;&#x2F;遍历棋盘的每一点 深度回溯</span><br><span class="line">	for(j &#x3D; 0; j &lt; 8; j ++) &#123;</span><br><span class="line">		if(check(i,j))&#123;</span><br><span class="line">			arr[i][j] &#x3D; 1;&#x2F;&#x2F;放置皇后</span><br><span class="line">			queen(i + 1);&#x2F;&#x2F;遍历下一层 </span><br><span class="line">			arr[i][j] &#x3D; 0;&#x2F;&#x2F;将此点重置为零，避免回溯出现脏数据</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	queen(0);</span><br><span class="line">	printf(&quot;%d\n&quot;,solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-附录</title>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95-%E9%99%84%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>本文是在学习算法阶段后。对快速排序、合并排序、堆排序时间复杂度、空间复杂度及优缺点总结；递归、回溯和DFS的区别；动态规划与贪心的区别。</p>
</blockquote>
<span id="more"></span>

<h4 id="1-快速排序-合并排序-堆排序时间复杂度-空间复杂度及优缺点总结"><a href="#1、快速排序、合并排序、堆排序时间复杂度、空间复杂度及优缺点总结。" class="headerlink" title="1、快速排序、合并排序、堆排序时间复杂度、空间复杂度及优缺点总结。"></a>1、快速排序、合并排序、堆排序时间复杂度、空间复杂度及优缺点总结。</h4><p><strong>时间复杂度：三种排序算法的平均时间复杂度为O(nlog(n)),快排的最坏时间复杂度是O(n2)。</strong></p>
<p><strong>空间复杂度：快速排序和堆排序都是就地排序，空间复杂度都为O(1)，合并排序需要合并两个数组，因此必须开辟新的空间，空间复杂度为O(n)。</strong></p>
<p><strong>稳定性：合并排序是稳定的排序，快排和堆排序不是稳定的排序。</strong></p>
<p><strong>一班情况下快排是最快的排序算法。</strong></p>
<p><strong>问题：尽管这两种排序算法的时间复杂度都是O(nlogn)，甚至堆排序和合并排序比快速排序的时间复杂度还要稳定，但是，是实际软件开发中，快速的排序的性能要比堆排序和合并好，这是为什么？</strong></p>
<p><strong>第一、堆排序访问数据的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的。而对于堆排序和合并排序来说，数据是跳着访问的，这样对CPU缓存是不友好的。</strong></p>
<p><strong>第二、对于同样的数据，在排序过程中，堆排序算法和合并的数据交换次数要多于快速排序。堆排序第一步是建堆，建堆的过程就会打乱数据原有的相对选择顺序，导致数据的有序度降低。快排的内存写操作次数平摊下来是T(n*lg(n)/2)，而归并的内存写操作次数是严格的O(n*log(n))，由于内存写操作开销比较大，所以对于随机数据快排优于归并。</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E9%99%84%E5%BD%95/16.1.png"></p>
<h4 id="2-递归-回溯和dfs的区别"><a href="#2、递归、回溯和DFS的区别。" class="headerlink" title="2、递归、回溯和DFS的区别。"></a>2、递归、回溯和DFS的区别。</h4><p><strong>（1）递归是一种算法结构，回溯是一种算法思想。</strong></p>
<p><strong>（2）一个递归就是在函数中调用函数本身来解决问题。</strong></p>
<p><strong>（3）回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。</strong></p>
<p><strong>剪枝的意思也就是说对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化。</strong></p>
<p><strong>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</strong></p>
<p><strong>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。</strong></p>
<p><img src="/2021/04/10/%E7%AE%97%E6%B3%95-%E9%99%84%E5%BD%95/16.2.png"></p>
<h4 id="3-动态规划与贪心的区别"><a href="#3、动态规划与贪心的区别" class="headerlink" title="3、动态规划与贪心的区别"></a>3、动态规划与贪心的区别</h4><p><strong>相同点：动态规划和贪心都是一种递推算法，都是由局部最优解推导全局最优解。</strong></p>
<p><strong>不同点：1.贪心算法中，贪心追求每步的最优解，所以贪心的每一步最优解一定包含上一步的最优解。2.动态规划中，全局最优解一定包含某个局部最优解，但不一定包含前一个局部最优解，因此动态规划需要将每步之前的最优解的结果存储起来，后面用到再拿来用，减少计算量。</strong></p>
<p><strong>总结：贪心是动态规划的特例，贪心不一定得到全局最优解，动态规划能够得到全局最优解。贪心通常用在局部最优对于当前问题是显而易见的最优情况。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>终端命令</title>
    <url>/2021/04/10/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>主要记录终端命令包含Windows和Linux 命令</p>
</blockquote>
<span id="more"></span>

<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><h4 id="cmd打开软件"><a href="#cmd打开软件" class="headerlink" title="cmd打开软件"></a>cmd打开软件</h4><ul>
<li>打开软件根目录即exe文件目录</li>
<li>doskey “标记”=“目录” ex：doskey IJ =”D:\apps\IntelliJ IDEA 2019.1.3\bin\idea64.exe” 目录有空格加“”号</li>
<li>在终端直接输入标记</li>
</ul>
<h4 id="chcp"><a href="#chcp" class="headerlink" title="chcp"></a>chcp</h4><ul>
<li>chcp 65001 换成UTF-8代码页</li>
<li>chcp 936 可以换回默认的GBK</li>
<li>chcp 437 是美国英语 </li>
</ul>
<h4 id="在终端上查看vnc在linux服务器上的端口号"><a href="#在终端上查看vnc在Linux服务器上的端口号" class="headerlink" title="在终端上查看vnc在Linux服务器上的端口号"></a>在终端上查看vnc在Linux服务器上的端口号</h4><ul>
<li>netstat -lp|grep -i vnc</li>
</ul>
<h4 id="退出远程桌面全屏"><a href="#退出远程桌面全屏" class="headerlink" title="退出远程桌面全屏"></a>退出远程桌面全屏</h4><ul>
<li>ctrl+ALt+break / ctrl +alt +fn+b</li>
</ul>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="远程服务器"><a href="#远程服务器" class="headerlink" title="远程服务器"></a>远程服务器</h4><ul>
<li>crontab -l 根据关键字查看日志</li>
<li>ls | grep digital 抓取关键字搜索</li>
</ul>
<h4 id="复制远程服务器文件到本地"><a href="#复制远程服务器文件到本地" class="headerlink" title="复制远程服务器文件到本地"></a>复制远程服务器文件到本地</h4><ul>
<li>scp <a href="mailto:&#x73;&#121;&#45;&#x64;&#x65;&#118;&#111;&#x70;&#115;&#x2d;&#117;&#115;&#101;&#x72;&#64;&#x34;&#55;&#x2e;&#x39;&#57;&#46;&#50;&#51;&#54;&#46;&#49;&#56;&#x31;">&#x73;&#121;&#45;&#x64;&#x65;&#118;&#111;&#x70;&#115;&#x2d;&#117;&#115;&#101;&#x72;&#64;&#x34;&#55;&#x2e;&#x39;&#57;&#46;&#50;&#51;&#54;&#46;&#49;&#56;&#x31;</a>:/data/work/scripts/allergan/user_behaviors/user_behavior.kjb D:\Data_work\etl</li>
<li>scp <a href="mailto:&#115;&#x79;&#x2d;&#x64;&#101;&#x76;&#x6f;&#x70;&#x73;&#x2d;&#x75;&#115;&#x65;&#114;&#x40;&#52;&#x37;&#x2e;&#57;&#57;&#46;&#x32;&#51;&#54;&#46;&#x31;&#56;&#49;">&#115;&#x79;&#x2d;&#x64;&#101;&#x76;&#x6f;&#x70;&#x73;&#x2d;&#x75;&#115;&#x65;&#114;&#x40;&#52;&#x37;&#x2e;&#57;&#57;&#46;&#x32;&#51;&#54;&#46;&#x31;&#56;&#49;</a>:/data/work/scripts/allergan/digital_ami_azure/exam.ktr C:\</li>
</ul>
<h4 id="linux解压和压缩"><a href="#Linux解压和压缩" class="headerlink" title="Linux解压和压缩"></a>Linux解压和压缩</h4><ul>
<li>zip -r archive_name.zip filename   （-r是压缩文件）</li>
<li>unzip archive_name.zip        （解压文件在当前文件下）</li>
<li>unzip archive_name.zip -d new_dir  （解压文件可以将文件解压缩至一个你指定的的目录，使用-d参数）</li>
</ul>
<h4 id="linux-重命名文件"><a href="#linux-重命名文件" class="headerlink" title="linux 重命名文件"></a>linux 重命名文件</h4><ul>
<li>eg:将目录A重命名B</li>
<li>mv a b</li>
<li>eg:将/a目录移动到/b下</li>
<li>并重命名c</li>
<li>mv /a /b/c</li>
</ul>
<h4 id="linux-创建文件和文件夹"><a href="#linux-创建文件和文件夹" class="headerlink" title="linux 创建文件和文件夹"></a>linux 创建文件和文件夹</h4><ul>
<li>mkdir</li>
</ul>
<p><img src="/2021/04/10/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/software\有道云\data\que_wen_bin@163.com\a4213457c36f4e45997cc2c13d4c8dee\image(1).png" alt="img"></p>
<p><img src="/2021/04/10/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/software\有道云\data\que_wen_bin@163.com\b0b94bfb820d4a4c85dfcb1e307c0062\ru5erkjggg==.png" alt="img"></p>
<p><img src="/2021/04/10/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/software\有道云\data\que_wen_bin@163.com\667a46a3f4954b748e171db5c2e33692\image(2).png" alt="img"></p>
<p><img src="/2021/04/10/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/software\有道云\data\que_wen_bin@163.com\92ce4b87b4ea40fa8d7db8a276dfc5a6\suvork5cyii=.png" alt="img"></p>
<h4 id="输入法仅桌面"><a href="#输入法（仅桌面）" class="headerlink" title="输入法（仅桌面）"></a>输入法（仅桌面）</h4><ul>
<li>cmd ctfmon</li>
</ul>
<h4 id="linux定位日志文件错误信息"><a href="#linux定位日志文件错误信息" class="headerlink" title="linux定位日志文件错误信息**"></a>linux定位日志文件错误信息**</h4><h4 id="定位日志文件错误信息"><a href="#定位日志文件错误信息" class="headerlink" title="定位日志文件错误信息"></a>定位日志文件错误信息</h4><p>示例：</p>
<p>cat all_info.log | grep “错误的关键信息提示” -C 10</p>
<h4 id="修改文件所有者和组"><a href="#修改文件所有者和组" class="headerlink" title="修改文件所有者和组"></a>修改文件所有者和组</h4><p> <strong>chgrp groupb filea</strong>   <strong>–改变filea所属群组</strong></p>
<p><strong>chown [-R] 账号名称   文件/目录</strong></p>
<h4 id="修改用户主目录"><a href="#修改用户主目录" class="headerlink" title="修改用户主目录"></a>修改用户主目录</h4><p>1.直接编辑 /etc/passwd</p>
<p>2.usermod -d /usr/newfolder -u uid         id username:查ID</p>
<h4 id="linux-根据关键字查找文件且输出文件名"><a href="#linux-根据关键字查找文件，且输出文件名" class="headerlink" title="linux 根据关键字查找文件，且输出文件名"></a>linux 根据关键字查找文件，且输出文件名</h4><p>sudo find /data/allergan/allergan_members -name ‘wechat_members*’ | head -n 1 | sed ‘s#.*/##’</p>
<h4 id="linux-将命令结果赋值给变量"><a href="#linux-将命令结果赋值给变量" class="headerlink" title="linux 将命令结果赋值给变量"></a>linux 将命令结果赋值给变量</h4><p>log=<code>ls</code></p>
<p>echo $log</p>
<p>log=$(ls)</p>
<p>echo $log</p>
<h4 id="linux-查看文件大小"><a href="#linux-查看文件大小" class="headerlink" title="linux 查看文件大小"></a>linux 查看文件大小</h4><p>du -sh *查看当前目录下各个文件及目录占用空间大小</p>
<p>du -sh 查看当前目录的总大小</p>
<p>df -h 查看系统中文件的使用情况</p>
<p>## Linux 查看当前目录</p>
<p>pwd</p>
<h4 id="linux-创建脚本文件"><a href="#Linux-创建脚本文件" class="headerlink" title="Linux 创建脚本文件"></a>Linux 创建脚本文件</h4><p>touch clear_logs.sh</p>
<h4 id="linux-删除一个文件夹下所有文件"><a href="#linux-删除一个文件夹下所有文件" class="headerlink" title="linux  删除一个文件夹下所有文件"></a>linux  删除一个文件夹下所有文件</h4><p>cd 目录</p>
<p>rm -rf *</p>
<h4 id="linux-删除一个文件夹"><a href="#Linux-删除一个文件夹" class="headerlink" title="Linux 删除一个文件夹"></a>Linux 删除一个文件夹</h4><p>rm -rf /目录</p>
<p>## 删除文件时出现 “操作无法完成，因为文件已在另一个程序中打开”</p>
<p>解决方法：</p>
<p>启动任务管理器——性能——资源监视器——CPU选项卡——关联的句柄——搜索句柄</p>
<p>——（输入）要删除的文件夹名——搜索到与文件夹名句柄相关联的进程 （由于此程序进程正在调用文件夹，才造成了对该文件夹删除的失败。）</p>
<p>——(右键)该进程——结束进程——弹出警告对话框——确认后即可结束该进程，然后就 可以完美删除该文件夹或者文件了。</p>
<h4 id="查看进程端口号"><a href="#查看进程端口号" class="headerlink" title="查看进程端口号"></a>查看进程端口号</h4><p>  netstat -ano</p>
<h4 id="查看指定端口占用情况"><a href="#查看指定端口占用情况" class="headerlink" title="查看指定端口占用情况"></a>查看指定端口占用情况</h4><p>netstat -ano|findstr “8080”</p>
<h4 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程**"></a>关闭进程**</h4><p>tasklist|findstr “127704”</p>
<h4 id="修改linux-服务器桌面分辨率"><a href="#修改linux-服务器桌面分辨率" class="headerlink" title="修改linux 服务器桌面分辨率"></a>修改linux 服务器桌面分辨率</h4><p>– xrandr</p>
<p>– xrandr -s 1920x1080</p>
<h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>sudo systemctl stop iptables</p>
<h4 id="重启crontab"><a href="#重启crontab" class="headerlink" title="重启crontab"></a>重启crontab</h4><p>sudo systemctl restart crond</p>
<h4 id="kettle闪退"><a href="#kettle闪退" class="headerlink" title="kettle闪退"></a>kettle闪退</h4><p>“$_PENTAHO_JAVA” $OPT -jar “$STARTUP” -lib $LIBPATH “${1+$@}” 2&gt;&amp;1</p>
<h4 id="切换桌面环境"><a href="#切换桌面环境" class="headerlink" title="切换桌面环境"></a>切换桌面环境</h4><p>startx 或者 init 5</p>
<h4 id="查看ftp用户"><a href="#查看ftp用户" class="headerlink" title="查看ftp用户"></a>查看ftp用户</h4><p>cat /etc/passwd | grep ftp</p>
<h4 id="重启vsftpd服务器"><a href="#重启vsFTPd服务器" class="headerlink" title="重启vsFTPd服务器"></a>重启vsFTPd服务器</h4><p>service vsftpd restart</p>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>:w      - 保存文件，不退出 vim</p>
<p>:w file -将修改另外保存到 file 中，不退出 vim</p>
<p>:w!     -强制保存，不退出 vim</p>
<p>:wq     -保存文件，退出 vim</p>
<p>:wq!    -强制保存文件，退出 vim</p>
<p>:q      -不保存文件，退出 vim</p>
<p>:q!     -不保存文件，强制退出 vim</p>
<p>:e!     -放弃所有修改，从上次保存文件开始再编辑</p>
<p>ctrl+s 锁住  ctrl + q 解除锁定</p>
<h4 id="改变文件夹所属用户和组"><a href="#改变文件夹所属用户和组" class="headerlink" title="改变文件夹所属用户和组"></a>改变文件夹所属用户和组</h4><p>chown -R 所有者用户名.组名 文件夹名称</p>
<p>例如：chown -R zdz.nginx KooBox</p>
<h4 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h4><p>添加用户并设置主目录</p>
<p>useradd -d /home/www -g ftpgroup ftptest</p>
<p>删除用户</p>
<p>userdel -r ftptest</p>
<p>用户列表</p>
<p>cat /etc/passwd</p>
<h4 id="设置sftp-并设置主目录但是限制在主目录中禁止返回上级目录amp禁止用于系统登录没有实现"><a href="#设置sftp-并设置主目录（但是限制在主目录中，禁止返回上级目录-amp-禁止用于系统登录没有实现）" class="headerlink" title="设置sftp ,并设置主目录（但是限制在主目录中，禁止返回上级目录&amp;禁止用于系统登录没有实现）"></a>设置sftp ,并设置主目录（但是限制在主目录中，禁止返回上级目录&amp;禁止用于系统登录没有实现）</h4><p>安装/卸载vsftpd服务</p>
<p>yum -y install vsftpd</p>
<p>yun remove vsftpd</p>
<h4 id="配置vsftpd配置文件"><a href="#配置vsftpd配置文件" class="headerlink" title="配置vsftpd配置文件"></a>配置vsftpd配置文件</h4><p>vi /etc/vsftpd/vsftpd.conf</p>
<h4 id="启动重启关闭状态"><a href="#启动-重启-关闭-状态" class="headerlink" title="启动/重启/关闭/状态"></a>启动/重启/关闭/状态</h4><p>service vsftpd start/restart/stop/status </p>
<h4 id="创建ftp用户"><a href="#创建ftp用户" class="headerlink" title="创建ftp用户"></a>创建ftp用户</h4><p>useradd -d /home/username username</p>
<h4 id="创建用户组"><a href="#创建用户组" class="headerlink" title="创建用户组"></a>创建用户组</h4><p>groupadd ftpgroups</p>
<h4 id="ssh无法远程报错system-is-booting-up-see-pam_nologin8"><a href="#ssh无法远程-报错”System-is-booting-up-See-pam-nologin-8-”" class="headerlink" title="ssh无法远程,报错”System is booting up. See pam_nologin(8)”"></a>ssh无法远程,报错”System is booting up. See pam_nologin(8)”</h4><p>修改文件： /etc/pam.d/sshd</p>
<p>vim /etc/pam.d/sshd</p>
<p>注释account required pam_nologin.so。即在这一行前边加#。保存即可</p>
<h4 id="为普通用户添加sudo权限"><a href="#为普通用户添加sudo权限" class="headerlink" title="为普通用户添加sudo权限"></a>为普通用户添加sudo权限</h4><p>root用户</p>
<p>vim /etc/sudoers //打开sudo的配置文件</p>
<p>在“root ALL=(ALL)ALL”这一行下面，加入如下图所示的一行 用户名 ALL=(ALL) ALL</p>
<h4 id="windows-具有管理员权限的账号或administrator-修改其他用户密码"><a href="#windows-具有管理员权限的账号或administrator-修改其他用户密码" class="headerlink" title="windows 具有管理员权限的账号或administrator 修改其他用户密码"></a>windows 具有管理员权限的账号或administrator 修改其他用户密码</h4><p>打开Windows PowerShell(管理员)</p>
<p>例：修改administrator密码为123456</p>
<p>net user administrator 123456</p>
<h4 id="查看centos版本"><a href="#查看CentOS版本" class="headerlink" title="查看CentOS版本"></a>查看CentOS版本</h4><p>cat /etc/redhat-release</p>
<h4 id="批量修改文件为可执行文件"><a href="#批量修改文件为可执行文件" class="headerlink" title="批量修改文件为可执行文件"></a>批量修改文件为可执行文件</h4><p>chmod +x test2.sh</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>终端命令</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP拥塞控制</title>
    <url>/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>摘要：本次论文以5-39题展开论述，讨论TCP的拥塞窗口随着传输轮次n的变化，在各个阶段使用不同TCP拥塞控制算法。通过实例详细论述各个算法的工作机制及工作时段。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，即∑对资源的需求&gt;可用资源。这种情况就叫做拥塞。而TCP作为整个网络运输层的通信协议，就有拥塞避免的算法。它使用一套线增积减的模式多样化网络拥塞控制方法来控制拥塞。其主要的算法有四种即慢开始、拥塞避免、快重传、快恢复。</p>
<p>关键词：拥塞避免；慢开始；快重传；快恢复；</p>
</blockquote>


	<div class="row">
    <embed src="pdf.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章目录跳转</title>
    <url>/2021/04/19/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%A4%B9/Untitled%201/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ETL即数据抽取（Extract）、转换（Transform）、装载（Load）的过程。</p>
<h3 id="抽取策略"><a href="#抽取策略" class="headerlink" title="抽取策略"></a>抽取策略</h3><ul>
<li>时间戳方式</li>
</ul>
<p>需要在<em>OLTP</em>（<strong>联机事务处理系统）</strong>系统中业务表中统一添加时间字段作为时戳（如表中已有相应的时间字段，可以不必添加），每当<em>OLTP</em>系统中更新修改业务数据时，必须同时修改时戳字段值。当作<em>ETL</em>加载时，通过系统时间与时戳字段的比较来决定进行何种数据抽取。</p>
<p>​    优点：<em>ETL</em>系统设计清晰，源数据抽取相对清楚简单，速度快。<strong>可以实现数据的递增加载</strong>。</p>
<p>​    缺点：时戳维护需要由<em>OLTP</em>系统完成，需要修改原<em>OLTP</em>系统中业务表结构；且所有添加时戳的表，在业务系统中，数据发生变化时，同时更新时戳字段，需要对原<em>OLTP</em>系统业务操作程序作修改，工作量大，改动面大，风险大。但如果业务表在最初设计的时候考虑到这点，应用此方案是最好的选择。</p>
<ul>
<li>日志表方式</li>
</ul>
<p>在<em>OLTP</em>系统中添加系统日志表，当业务数据发生变化时，更新维护日志表内容，当作<em>ETL</em>加载时，通过读日志表数据决定加载那些数据及如何加载。</p>
<p>​    优点：不需要修改<em>OLTP</em>表结构，源数据抽取清楚，速度较快。<strong>可以实现数据的递增加载。</strong></p>
<p>​    缺点：日志表维护需要由<em>OLTP</em>系统完成，需要对<em>OLTP</em>系统业务操作程序作修改，记录日志信息。日志表维护较为麻烦，对原有系统有较大影响。工作量较大，改动较大，有一定风险。</p>
<ul>
<li>全表比对方式</li>
</ul>
<p>在<em>ETL</em>过程中，抽取所有源数据，并进行相应规则转换，完成后先不插入目标，而对每条数据进行目标表比对。根据主键值进行插入与更新的判定，目标表已存在该主键值的，表示该记录已有，并进行其余字段比对，如有不同，进行<em>Update</em>操作，如目标表没有存在该主键值，表示该记录还没有，即进行<em>Insert</em>操作。</p>
<p>优点：对已有系统表结构不产生影响，不需要修改业务操作程序，所有抽取规则由<em>ETL</em>完成，管理维护统一，可以实现数据的递增加载，没有风险。</p>
<p>缺点：<em>ETL</em>比对较复杂，设计较为复杂，速度较慢</p>
<ul>
<li>全表删除插入方式</li>
</ul>
<p>每次<em>ETL</em>操作均删除目标表数据，由<em>ETL</em>全新加载数据。</p>
<p>​    优点：<em>ETL</em>加载规则简单，速度快。</p>
<p>​    缺点：对于维表加代理键不适应，当<em>OLTP</em>系统产生删除数据操作时，<em>OLAP</em>层将不会记录到所删除的历史数据。不可以实现数据的递增加载。</p>
<ul>
<li>设置触发器方式</li>
</ul>
<p>通过在源系统的数据库中设置触发器，每当有<em>Update</em>、<em>Insert</em>、<em>Delete</em>操作时触发一个事件将发生改变的记录抽取到相应的临时表中。</p>
<p>​    优点：<em>ETL</em>加载规则简单，速度快，不需要修改<em>OLTP</em>表结构，可以实现数据的递增加载。</p>
<p>​    缺点：对源系统性能有一些影响。需建立一张临时表。</p>
<ul>
<li>Oracle 变化数据捕捉（CDC 方式）</li>
</ul>
<p><em>CDC</em>特性是在<em>Oracle9i</em>数据库中引入的，它简化了识别自上次提取后发生变化的数据的过程。<em>CDC</em>能够帮助识别从上次提取之后发生变化的数据。利用<em>CDC</em>，在对源表进行<em>Update</em>、<em>Insert</em>或<em>Delete</em>等操作的同时就可以提取数据，并且变化的数据被保存在数据库的变化表中。这样就可以捕获发生变化的数据，然后利用数据库视图以一种可控的方式提供给目标系统。</p>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><h4 id="oltp-olap"><a href="#OLTP-OLAP" class="headerlink" title="OLTP OLAP"></a>OLTP OLAP</h4><p>从字面上来看OLTP是做事务处理，OLAP是做分析处理。从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询。</p>
]]></content>
  </entry>
  <entry>
    <title>私密文章</title>
    <url>/2021/04/18/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%A4%B9/%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4a42d64c0f76be6975d945d5a101c2ad88d64cfaf2a6c69d1197a13cc17b71a1">664409823499d5cb01b284302c5d7e5f39ccad78e6dbea3e1b49b291c9e57f6c48f63a371da3060338faf0b059a28706cbefb03f3d9fe1dfd5e58895fa787e6e91bf8e2f13a5d8a61422505d7b497962bd0f1635eec0a8e32672c58fbc2aaff7079a2f23415b6027d522542003495190f3c4f5371db63f311d25dd82e86c6dcfffeea794abd405d634425a3fb2422e5a104331ced08709b3cf30d2350dcab8f8c9fe8c98cf7ec11d3f1637df690bdeb70636063bde2d5e772f96438c27e0aec233a543ade7acac55540fe1fd7f22ea7960533e40284b99b31d871be8f6e3e18b5dfd7b71a79659e62fc78a7ffb9951c55b0ac4738655a99d87044f91fc3f34c1f62f6f684af145aa2e8c7397868a19b3144b3e61f7a2c379e8225aece140c25c5c3a009332a942ef0b62ea4e49c52a41</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>访问七牛云资源测试</title>
    <url>/2021/04/19/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%A4%B9/%E8%AF%97%E9%9B%86%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5b81429a22a16a38fba7427e45cac69c9b15bee6ba786fbf4d5f04f628885315">4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428c11c93f384188a4b2c3fe186736ec47075694e90dee670f0008b512c63e99b241203e76646420adad247b6a0aa73d4a0ca83a152b5a115bf216df9c6ea4e738ad9cc2227ac74833edb55d067d33c851b403c177751f9a3d9a514405310a0530f78ee12f718267c982099276b86268ee3e3e30bc81e9ff2da6c96966a33eaff9e34041ceba68a8a6dba4c32038ceac32338bfba484770e96cedfa44306741854e3c04f5f02ffc01d7f4edf6fa26f057fc719f26bea446e9e591ccd22107d819fc8b1585aa7d8cc82f4f4e0a1325466f8357e9a37534e3ebed0aa398dd934adbaec9cc0a51c2722e5ba6d1f56569a984991a83f03ebe14810bb1d60514c801f5b417e1019266ca2bb895a266e21a669268f8635ecd6df4a7eca9d4d6c28e5d68e13704ad1fc51db802bd482eb82b0cc49c5c18b89f2f08cb1e69798d38b07e347bac0b5cdfb8b9b436105d404c1721a21c8373196c92355f3d79b586f5f540a278af19641205ecc848c1742da86c3b6ac6a25634eaaf9aee92a896fde367bf2449ebe2531ec7452101b9b9186b7842f4cd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>加密文章测试</title>
    <url>/2021/04/16/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%A4%B9/%E8%AF%97%E9%9B%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="96c8394197e77f251a4af78ed9bdf8bb8441790263f278e70638771530b3545b">6031008eaf30dfa9f6cee48a6a69006e7a87339305ade939fc8f896a83a32b7828cb007fa2f43d2f24259ad4ed8fb226730933029b03fa8f2c102e596befb99c44dfcc665b6655e8a858f8d8b6f49db595f21289a018b01d49249426b00c68ab6e534431ef7163ef8180195441b5f8c4ae20f4001cf7c5e189dc034c57bfc6d2607a1d40ebc33e0c2f8d01d5fd71dc6361db2fe62e2a5d6815f996d100c7fec33bb36b7990298704ebd7ee8a0feaf31264b0cfd5faccdbf12e3ddd34c348729a26ac1e605d75f84092b502807939002efb7dd9f299ea6b667ca5e9f221d03eee7e6583b988548aadc32211c0e3c6c303ff99de41f7b081da77cb9943a569feadee029f24a37346c9a74206c167b9a9161f097dbb769350c47931ec53ca8c238a0ed8b948ee6042ba0f180b68c88484e280062d6d9a2dd02971160fc87f7b88c194e3dcd1f576338e21642475bb84b75f3d792f7cdef74d198dc01025b78e28326bdf9655f63f1da7a1e557e03814028ebcc2b5a5e814ce2e11e074d8062f5b90eca6e3b282856a4b7f2df7cc1aeaa6057909b69d7282bd371b7c2dc51ac7700995f5eb4d212a76e83d5a51ff806cdae7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
